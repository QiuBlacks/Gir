# Redis缓存穿透、击穿、雪崩



## 如何保证缓存和数据库的数据一致性？ 

**方式一：**

 读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况。串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。

**方式二：**

 先更新数据库，假如读缓存失败，先读数据库，再回写缓存的方式实现

https://developer.aliyun.com/article/712285



# 一、缓存穿透（查不到）  

## 1、概念

缓存穿透是指**缓存和数据库中都没有的数据**，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。

用户想要查询一个数据，发现redis内存数据库没有，也就是缓存没有命中，于是向持久层数据库查询。发现也没有，于是本次查询失败。当很多用户查询的时候，缓存都没有命中（例如秒杀系统！），于是都去请求了持久层数据库。这会给持久层数据库造成很大的压力，这时候就相当于出现了缓存穿透  

![image-20200929211128320](https://gitee.com/BlacksJack/picture-bed/raw/master/img/20200929211128.png)

## 2、解决方案

### 2.1 布隆过滤器

布隆过滤器是一种数据结构，对所有可能查询的参数以hash形式存储，在控制层先**进行校验，不符合则丢弃**，从而避免了对底层存储系统的查询压力  。判断key是否在数据库中，不存在就直接return，存在就进行数据库查询

将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力

### 2.2 缓存空对象  

从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null

当存储层不命中后，即返回的空对象也将其缓存起来，同时会设置一个**过期时间**，之后再访问这个数据将会从缓存中获取，保护了后端数据源；  

#### 2）存在问题

如果空值能够被缓存起来，这就意味着缓存需要更多的空间存储更多的键，因为这当中可能会有很多的空值的键；

即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响  

### 2.3 接口校验

接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截；



# 二、缓存击穿（量太大，缓存过期！）  

## 1、概述

缓存击穿，是指一个key非常热点（经常被访问），在不停的扛着大并发，**大并发集中对这一个key点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞**。

当某个key在过期的瞬间，有大量的请求并发访问，这类数据一般是热点数据，由于缓存过期，会同时访问数据库来查询最新数据，并且回写缓存，会导使数据库瞬间压力过大  

## 2、解决方案

### 2.1 设置热点数据永不过期

从缓存层面来看，没有设置过期时间，所以不会出现热点 key 过期后产生的问题。

### 2.2 加互斥锁

分布式锁：使用分布式锁，保证对于每个key同时**只有一个线程去查询**后端服务，其他线程没有获得分布式锁的权限，因此只需要等待即可。这种方式将高并发的压力转移到了分布式锁，因此对分布式锁的考验很大  

![image-20200929211733190](https://gitee.com/BlacksJack/picture-bed/raw/master/img/20200929211733.png)





# 三、缓存雪崩

## 1、概念

**缓存雪崩**是指缓存同一时间大面积的**失效（过期）**，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。Redis 宕机！

产生雪崩的原因之一，比如在写本文的时候，马上就要到双十二零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。

而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况  

<img src="https://gitee.com/BlacksJack/picture-bed/raw/master/img/20200929211920.png" alt="image-20200929211920106" style="zoom:67%;" />

其实集中过期，倒不是非常致命，比较致命的缓存雪崩，是缓存服务器某个节点宕机或断网。因为自然形成的缓存雪崩，一定是在某个时间段集中创建缓存，这个时候，数据库也是可以顶住压力的。无非就是对数据库产生周期性的压力而已。而缓存服务节点的宕机，对数据库服务器造成的压力是不可预知的，很有可能瞬间就把数据库压垮  



## 2、解决方案  

### 2.1 redis高可用

使用 Redis 集群来保证 Redis 服务不会挂掉

这个思想的含义是，既然redis有可能挂掉，那我多增设**几台redis**，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群。（异地多活！）

### 2.2 限流降级（在SpringCloud讲解过！）

在缓存失效后，通过**加锁或者队列来控制读数据库写缓存的线程数量**。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。

### 2.3 数据预热

数据加热的含义就是在正式部署之前，我先把可能的数据先预先访问一遍，这样部分可能**先将大量访问的数据就会加载到缓存**中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀  

### 2.4 设置不同缓冲时间

在可接受的时间范围内随机设置key的过期时间，分散key的过期时间，以防止大量的key在同一时刻过期；

设置缓存时间不一致，给缓存的失效时间，加上一个随机值，避免集体失效



- 设置key永不失效（热点数据）；

