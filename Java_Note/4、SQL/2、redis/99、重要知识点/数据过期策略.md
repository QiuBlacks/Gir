# 一、数据过期策略

Redis 中数据过期策略采用**惰性删除 + 定期删除**策略，memcached只是用了惰性删除

## 1、惰性删除

### 1）定义

key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null

### 2）优点

删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的，而且此时的删除是已经到了非做不可的地步（如果此时还不删除的话，我们就会获取到了已经过期的key了）

### 3）缺点

若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露（无用的垃圾占用了大量的内存）



## 2、定时删除

### 1）含义

在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除

### 2）优点

保证内存被尽快释放

### 3）缺点

- 若过期key很多，删除这些key会占用很多的CPU时间，在CPU时间紧张的情况下，CPU不能把所有的时间用来做要紧的事儿，还需要去花时间删除这些key

- 定时器的创建耗时，若为每一个设置过期时间的key创建一个定时器（将会有大量的定时器产生），性能影响严重

  

## 3、定期删除

### 1）定义

每隔一段时间执行一次删除(在**redis.conf配置文件**设置hz，1s刷新的频率)过期key操作

Redis 启用一个定时器定时监视所有的 key，判断key是否过期，过期的话就删除。

### 2）优点

- 通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用--处理"定时删除"的缺点
- 定期删除过期key--处理"惰性删除"的缺点

### 3）缺点

- 在内存友好方面，不如"定时删除"
- 在CPU时间友好方面，不如"惰性删除"

每次都遍历内存中所有的数据，非常消耗 CPU 资源，并且当 key 已过期，但是定时器还处于未唤起状态，这段时间内 key 仍然可以用。

### 4）配置

- 第一、配置redis.conf 的hz选项，默认为10 （即1秒执行10次，100ms一次，值越大说明刷新频率越快，最Redis性能损耗也越大） 
- 第二、配置redis.conf的**maxmemory**最大值，当已用内存超过maxmemory限定时，就会触发主动清理策略



这两种策略天然的互补，结合起来之后，定期删除策略就发生了一些改变，不在是每次扫描全部的 key 了，而是**随机抽取一部分 key 进行检查**，这样就降低了对 CPU 资源的损耗，惰性删除策略互补了为检查到的key，基本上满足了所有要求。但是有时候就是那么的巧，既没有被定时器抽取到，又没有被使用，这些数据又如何从内存中消失？没关系，还有内存淘汰机制，当内存不够用时，**内存淘汰机制**就会上场。





# 二、Redis数据过期策略

## 1、Redis采用的过期策略

惰性删除+定期删除

- 惰性删除流程

  - 在进行get或setnx等操作时，先检查key是否过期，
  - 若过期，删除key，然后执行相应操作；
  - 若没过期，直接执行相应操作

- 定期删除流程（简单而言，对指定个数的每一个库随机删除小于等于指定个数个过期key）

  - 遍历每个数据库（就是redis.conf中配置的"database"数量，默认为16）

    - 检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体时下边的描述）

      - 如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历
      - 随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key
      - 判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。

      

## 2、具体操作

### 2.1 命令

Redis对存储值的过期处理实际上是针对该值的键（key）处理的，即时间的设置也是设置key的有效时间。Expires字典保存了所有键的过期时间，Expires也被称为过期字段。

- expire key time(以秒为单位)--这是最常用的方式
- setex(String key, int seconds, String value)--**字符串独有的方式**
- PERSIST <key> ：表示将key的过期时间移除（永久有效）
- TTL <key> ：以秒的单位返回键 key 的剩余生存时间。
- PTTL <key> ：以毫秒的单位返回键 key 的剩余生存时间。



expire都是以秒为单位，pexpire都是以毫秒为单位的

```java
EXPIRE key seconds　　//将key的生存时间设置为ttl秒
PEXPIRE key milliseconds　　//将key的生成时间设置为ttl毫秒
EXPIREAT key timestamp　　//将key的过期时间设置为timestamp所代表的的秒数的时间戳
PEXPIREAT key milliseconds-timestamp　　//将key的过期时间设置为timestamp所代表的的毫秒数的时间戳
```

备注：timestamp为unix时间戳（例如：timestamp=1499788800 表示将在2017.07.12过期）



### 2.2 示例

expire 

```
127.0.0.1:6379> SET akey redis
OK
127.0.0.1:6379> EXPIREAT akey 1393840000
(integer) 1
127.0.0.1:6379> EXISTS akey
(integer) 0
127.0.0.1:6379> SET akey redis
OK
127.0.0.1:6379> EXPIREAT akey 1493840000
(integer) 1
127.0.0.1:6379> EXISTS akey
(integer) 1
```

setex

```
1 redis 127.0.0.1:6379> SETEX mykey 60 redis
2 OK
3 redis 127.0.0.1:6379> TTL mykey
4 60
5 redis 127.0.0.1:6379> GET mykey
6 "redis
```



# 三、内存淘汰策略

## 1、问题引出

我们看到，通过过期删除策略，对于某些永远使用不到的键，并且多次定期删除也没选定到并删除，那么这些键同样会一直驻留在内存中，又或者在Redis中存入了大量的键，这些操作可能会导致Redis内存不够用，这时候就需要Redis的内存淘汰策略了。

## 2、策略

在配置文件redis.conf 中，可以通过参数 **maxmemory <bytes>** 来设定最大内存：

当现有内存大于 maxmemory 时，便会触发redis主动淘汰内存方式，通过设置 **maxmemory-policy** 

有如下6种淘汰方式：

### 全局的键空间选择性移除（任何key）

- noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。
- allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。（这个是**最常用**的）
- allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。

### 设置过期时间的键空间选择性移除 (过期key)

- volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
- volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
- volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。



# 四、手写Redis的LRU

