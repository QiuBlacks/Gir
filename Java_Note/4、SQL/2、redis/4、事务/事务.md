# 事务

# 一、基础知识

## 1、基本介绍

Redis 事务本质：**一组命令的集合**！

事务支持**一次执行多个命令**，一个事务中所有命令都会被**序列化**。在事务执行过程，会按照**顺序串行化执行**队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。

```
------ 队列 set set set 执行------
```

redis事务就是**一次性、顺序性、排他性**的执行一个队列中的一系列命令。

## 2、redis事务特点

Redis的事务**总是具有ACID中的一致性和隔离性**，其他特性是不支持的。当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。

Redis中，单条命令是原子性执行的，但**事务不保证原子性，且没有回滚**。事务中任意命令执行失败，其余的命令仍会被执行。



==Redis事务没有没有隔离级别的概念！==

**redis 不支持回滚**，“Redis 在事务失败时不进行回滚，而是继续执行余下的命令”， 所以 Redis 的内部可以保持简单且快速。



## 3、redis的事务三个阶段

- 开启事务（multi）

- 命令入队（......）

- 执行事务（exec）  


事务执行过程中，如果服务端收到有**MULTI（开启事务）、EXEC（执行事务）、DISCARD（放弃事务）、WATCH（监控事务）**之外的请求，将会把请求放入队列中排队



# 二、基本命令操作

- WATCH 命令：是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，**一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令**。
- MULTI命令：用于开启一个事务，它总是返回OK。 MULTI执行之后，客户端可以继续向服务器发送任意多条命令，**这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行**。
- EXEC：执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。 当操作被打断时，返回空值 nil 。
- 通过调用DISCARD，客户端可以清空事务队列，并放弃执行事务， 并且客户端会从事务状态中退出。
- UNWATCH命令：可以取消watch对所有key的监控。



## 1、正常执行事务 

```bash
127.0.0.1:6379> multi # 开启事务
OK
# 命令入队
127.0.0.1:6379> set k1 v1
QUEUED
127.0.0.1:6379> set k2 v2
QUEUED
127.0.0.1:6379> get k2
QUEUED
127.0.0.1:6379> set k3 v3
QUEUED
127.0.0.1:6379> exec # 执行事务
1) OK
2) OK
3) "v2"
4) OK
```



## 2、放弃事务！  

```bash
127.0.0.1:6379> multi # 开启事务
OK
127.0.0.1:6379> set k1 v1
QUEUED
127.0.0.1:6379> set k2 v2
QUEUED
127.0.0.1:6379> set k4 v4
QUEUED
127.0.0.1:6379> DISCARD # 取消事务
OK
127.0.0.1:6379> get k4 # 事务队列中命令都不会被执行！
(nil)
```



## 3、异常

### 3.1 编译型异常

**如果在一个事务中的命令出现错误，那么所有的命令都不会执行**；

```bash
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set k1 v1
QUEUED
127.0.0.1:6379> set k2 v2
QUEUED
127.0.0.1:6379> set k3 v3
QUEUED
127.0.0.1:6379> getset k3 # 错误的命令
(error) ERR wrong number of arguments for 'getset' command
127.0.0.1:6379> set k4 v4
QUEUED
127.0.0.1:6379> set k5 v5
QUEUED
127.0.0.1:6379> exec # 执行事务报错！
(error) EXECABORT Transaction discarded because of previous errors.
127.0.0.1:6379> get k5 # 所有的命令都不会被执行！
(nil)
```



### 3.2 运行时异常

例如1/0，如果事务队列中存在运行错误，那么执行命令的时候，**正确的命令是可以正常执行的，错误命令抛出异常！**  

```bash
127.0.0.1:6379> set k1 "v1"
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> incr k1 # 会执行的时候失败！
QUEUED
127.0.0.1:6379> set k2 v2
QUEUED
127.0.0.1:6379> set k3 v3
QUEUED
127.0.0.1:6379> get k3
QUEUED
127.0.0.1:6379> exec
1) (error) ERR value is not an integer or out of range # 虽然第一条命令报错了，但是依旧正常执行成功了！
2) OK
3) OK
4) "v3"
127.0.0.1:6379> get k2
"v2"
127.0.0.1:6379> get k3
"v3"
```



# 三、redis的乐观锁实现：Watch 监控

WATCH 命令是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。 可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。



## 案例：

### 1、正常情况

```bash
127.0.0.1:6379> set money 100
OK
127.0.0.1:6379> set out 0
OK
127.0.0.1:6379> watch money # 监视 money 对象
OK
127.0.0.1:6379> multi # 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功！
OK
127.0.0.1:6379> DECRBY money 20
QUEUED
127.0.0.1:6379> INCRBY out 20
QUEUED
127.0.0.1:6379> exec
1) (integer) 80
2) (integer) 20
```



### 2、多线程并发情况

测试多线程修改值 , 使用watch 可以当做redis的乐观锁操作！  

exec执行之前，在另外一个线程，修改了我们money的值，这个时候，就会导致事务执行失败

```bash
127.0.0.1:6379> watch money # 监视 money
OK
127.0.0.1:6379> multi
OK
127.0.0.1:6379> DECRBY money 10
QUEUED
127.0.0.1:6379> INCRBY out 10
QUEUED
127.0.0.1:6379> exec # 执行之前，另外一个线程，修改了我们的值，这个时候，就会导致事务执行失
败！
(nil)
```



### 3、解决方法

解锁后再次监视

![image-20200922210339831](https://gitee.com/BlacksJack/picture-bed/raw/master/img/20200926152408.png)







