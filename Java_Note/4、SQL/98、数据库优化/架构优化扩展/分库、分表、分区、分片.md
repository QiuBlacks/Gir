# 分库

# 一、基本介绍

## 1、基本概念

分表能够解决单表数据量过大带来的查询效率下降的问题，但是，却无法给数据库的并发处理能力带来质的提升。面对高并发的读写访问，当数据库master服务器无法承载写操作压力时，不管如何扩展slave服务器，此时都没有意义了。因此，我们必须换一种思路，对数据库进行拆分，从而提高数据库写入能力，这就是所谓的分库



## 2、分库分表后存在问题

### 1）事务问题

在执行分库分表之后，由于数据存储到了不同的库上，数据库事务管理出现了困难。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价；如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担

### 2）跨库跨表的join问题

在执行了分库分表之后，难以避免会将原本逻辑关联性很强的数据划分到不同的表、不同的库上，这时，表的关联操作将受到限制，我们无法join位于不同分库的表，也无法join分表粒度不同的表，结果原本一次查询能够完成的业务，可能需要多次查询才能完成。

解决这一问题的普遍做法是**分两次查询实现。**在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。 分库分表方案产品

### 3）跨节点的count,order by,group by以及聚合函数问题

额外的数据管理负担，最显而易见的就是数据的定位问题和数据的增删改查的重复执行问题，这些都可以通过应用程序解决，但必然引起额外的逻辑运算，例如，对于一个记录用户成绩的用户数据表userTable，业务要求查出成绩最好的100位，在进行分表之前，只需一个order by语句就可以搞定，但是在进行分表之后，将需要n个order by语句，分别查出每一个分表的前100名用户数据，然后再对这些数据进行合并计算，才能得出结果。

解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。

### 4）唯一ID问题

一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由. 一些常见的主键生成策略

**UID** 使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题

 **Twitter的分布式自增ID算法Snowflake** 在分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。



## 3、解决方案

使用类似JTA提供的分布式事物机制

对于不同的方式之间没有严格的界限，特点不同，侧重点不同。需要根据实际情况，结合每种方式的特点来进行处理。

选用第三方的数据库中间件（Atlas，Mycat，TDDL，DRDS），同时业务系统需要配合数据存储的升级。

## 4、适用场景

- 单台DB的存储空间不够
- 随着查询量的增加单台数据库服务器已经没办法支撑

## 5、解决问题

为突破单节点数据库服务器的 I/O 能力限制，解决数据库扩展性问题





# 二、分类

### 1、垂直拆分

将系统中不存在关联关系（关联度低）或者需要join的表可以放在不同的数据库不同的服务器中。

按照业务垂直划分。比如：可以按照业务分为资金、会员、订单三个数据库。

需要解决的问题：跨数据库的事务、jion查询等问题。

### 2、水平拆分

把一个表的数据拆分到多个数据库，每个数据库中的表结构不变。用多个库抗更高的并发。比如订单表每个月有500万条数据累计，每个月都可以进行水平拆分，将上个月的数据放到另外一个数据库。



### 读写分离

对于时效性不高的数据，可以通过读写分离缓解数据库压力。需要解决的问题：在业务上区分哪些业务上是允许一定时间延迟的，以及数据同步问题。







# 分区

# 一、基本介绍

## 1、基本概念

  数据分区是一种物理数据库的设计技术，它的目的是为了在特定的SQL操作中减少数据读写的总量以缩减响应时间。

分区并不是生成新的数据表，而是将表的数据均衡分摊到**不同的硬盘，**系统或是不同服务器存储介子中，实际上还是一张表。另外，分区可以做到将表的数据均衡到不同的地方，提高数据检索的效率，降低数据库的频繁IO压力值

## 2、优点

- 相对于单个文件系统或是硬盘，分区可以存储更多的数据；

- 数据管理比较方便，比如要清理或废弃某年的数据，就可以直接删除该日期的分区数据即可；
- 精准定位分区查询数据，不需要全表扫描查询，大大提高数据检索效率；
- 可跨多个分区磁盘查询，来提高查询的吞吐量；
- 在涉及聚合函数查询时，可以很容易进行数据的合并；

## 3、适用场景

- 一张表的查询速度已经慢到影响使用的时候。
- 表中的数据是分段的
- 对数据的操作往往只涉及一部分数据，而不是所有的数据

## 4、实例

```sql
CREATE TABLE sales (
    id INT AUTO_INCREMENT,
    amount DOUBLE NOT NULL,
    order_day DATETIME NOT NULL,
    PRIMARY KEY(id, order_day)
) ENGINE=Innodb 
PARTITION BY RANGE(YEAR(order_day)) (
    PARTITION p_2010 VALUES LESS THAN (2010),
    PARTITION p_2011 VALUES LESS THAN (2011),
    PARTITION p_2012 VALUES LESS THAN (2012),
PARTITION p_catchall VALUES LESS THAN MAXVALUE);
```



# 二、分类

## 1、垂直分区

根据数据库里面**数据表的相关性**进行拆分。即把一张列比较多的表根据列的相关性拆分为多张表。

- 优点：可以使得行数据变小，简化表的结构。

- 缺点：

  - 主键会出现冗余，需要管理冗余列，并会引起 Join 操作（可以通过在应用层进行Join来解决）。

  - 垂直分区会让事务变得更加复杂。

    

## 2、水平分区

保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。

- 水平拆分最好分库。水平拆分能够支持非常大的数据量存储，应用端改造也少，但分片事务难以解决 ，跨界点 Join 性能较差，逻辑复杂。
- 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度。







------



# 分表

# 一、基本介绍

## 1、基本概念

**把一张表分成多个小表**

因一张表的数据量太大，用索引来查询数据都搞不定了，所以可以将一张表的数据拆分到多张表，查询时，只用查拆分后的某一张表，SQL 语句的查询性能得到提升。

## 2、垂直分表

把**主键和一些经常使用的字段**放在一个表，然后将不经常用或字段长度较大的字段拆分出去到扩展表中。

##### 适用场景

- 1、如果一个表中某些列常用，另外一些列不常用
- 2、可以使数据行变小，一个数据页能存储更多数据，查询时减少I/O次数

##### 缺点

- 有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差
- 对于应用层来说，逻辑算法增加开发成本
- 管理冗余列，查询所有数据需要join操作



## 3、水平分表：

表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数

##### 适用场景

- 表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。
- 需要把数据存放在多个介质上。



------



# 分表和分区

## 一、基本介绍

分表从表面意思说就是**把一张表分成多个小表**，分区则是把**一张表的数据分成N多个区块**，这些区块可以在同一个磁盘上，也可以在不同的磁盘上



## 二、分表和分区的区别

### 1、实现方式上 

mysql的分表是真正的分表，一张表分成很多表后，**每一个小表都是完正的一张表**，都对应**三个文件**（MyISAM引擎：一个.MYD数据文件，.MYI索引文件，.frm表结构文件）。

### 2、数据处理上 

分表后数据都是存放在分表里，总表只是一个外壳，存取数据发生在一个一个的分表里面。

分区则不存在分表的概念，分区只不过把存放数据的文件分成了许多小块，分区后的表还是一张表，数据处理还是由自己来完成

### 3、提高性能上 

 分表后，**单表的并发能力提高**了，**磁盘I/O性能也提高了**。

分区突破了**磁盘I/O瓶颈**，想**提高磁盘的读写能力**，来增加mysql性能。 

在这一点上，分区和分表的测重点不同，分表重点是存取数据时，如何提高mysql并发能力上；而分区呢，如何突破磁盘的读写能力，从而达到提高mysql性能的目的

### 4、实现的难易度上 

分表的方法有很多，用**merge**来分表，是最简单的一种方式。这种方式和分区难易度差不多，并且对程序代码来说可以做到透明的。如果是用其他分表方式就比分区麻烦了。 分区实现是比较简单的，建立分区表，跟建平常的表没什么区别，并且对代码端来说是透明的





# 分库分表之唯一ID

# 一、基础知识

## 1、为什么分库分表需要唯一 ID

- 如果要做分库分表，则必须得考虑表主键 ID 是全局唯一的，比如有一张订单表，被分到 A 库和 B 库。如果 两张订单表都是从 1 开始递增，那查询订单数据时就错乱了，很多订单 ID 都是重复的，而这些订单其实不是同一个订单。
- 分库的一个期望结果就是将访问数据的次数分摊到其他库，有些场景是需要均匀分摊的，那么数据插入到多个数据库的时候就需要交替生成唯一的 ID 来保证请求均匀分摊到所有数据库。

举个例子，你的订单表拆分为了 1024 张订单表，每个表的 id 都从 1 开始累加，这个肯定有问题了！

## 2、生成唯一 ID 的原则

- 全局唯一性
- 趋势递增
- 单调递增
- 信息安全



# 二、生成方式

### 方案一：独立数据库自增 id

这个方案就是说你的系统每次要生成一个 id，都是往一个独立库的一个独立表里插入一条没什么业务含义的数据，然后获取一个数据库自增的一个 id。拿到这个 id 之后再往对应的分库分表里去写入。



- 高并发的话，多个库的 ID 可能重复
- 信息不安全



### 方案二：UUID

这个每个人都应该知道吧，就是用 UUID 生成一个全局唯一的 id。

好处：每个系统本地生成，不要基于数据库来了。

缺点：

- UUID 太长、占用空间大。
- 不具有有序性，作为主键时，在写入数据时，不能产生有顺序的 append 操作，只能进行 insert 操作，导致读取整个 `B+` 树节点到内存，插入记录后将整个节点写回磁盘，当记录占用空间很大的时候，性能很差。



### 方案三：获取系统当前时间

这个方案的意思就是获取当前时间作为全局唯一的 id。但是问题是，并发很高的时候，比如一秒并发几千，会有重复的情况，这个肯定是不合适的。

一般如果用这个方案，是将当前时间跟很多其他的业务字段拼接起来，作为一个 id，如果业务上你觉得可以接受，那么也是可以的。

你可以将别的业务字段值跟当前时间拼接起来，组成一个全局唯一的编号，比如说订单编号：时间戳 + 用户 id + 业务含义编码。

- 高并发时，1 ms内可能有多个相同的 ID。
- 信息不安全



### 4、SnowFlake 雪花算法

SnowFlake 算法，是 Twitter 开源的分布式 id 生成算法。其核心思想就是：使用一个 64 bit 的 long 型的数字作为全局唯一 id。

![img](https://gitee.com/BlacksJack/picture-bed/raw/master/img/20201104203001.png)

这 64 个 bit 中，其中 1 个 bit 是不用的，然后用其中的 41 bit 作为毫秒数，用 10 bit 作为工作机器 id，12 bit 作为序列号。

基本原理

- 1 bit：不用，统一为 0
- 41 bits：毫秒时间戳，可以表示 69 年的时间。
- 10 bits：5 bits 代表机房 id，5 个 bits 代表机器 id。最多代表 32 个机房，每个机房最多代表 32 台机器。
- 12 bits：同一毫秒内的 id，最多 4096 个不同 id，自增模式。



优点：

- 毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。

- 不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。

- 可以根据自身业务特性分配bit位，非常灵活。

  

缺点：

- 强依赖机器时钟，如果机器上时钟回拨（可以搜索 **2017 年闰秒 7:59:60**），会导致发号重复或者服务会处于不可用状态。



























# 参考资料：

​		[1]   https://blog.csdn.net/qq_28289405/article/details/80576614