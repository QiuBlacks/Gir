# 第四章、Schema与数据类型优化

# 4.1、选择优化的数据类型  

## 数据类型的选择原则：

### 1）更小的通常更好

一般情况下， 应该尽量使用可以正确存储数据的最小数据类型。 更小的数据类型通常更快， 因为它们占用更少的磁盘、 内存和CPU缓存， 并且处理时需要的CPU周期也更少。  

### 2）简单就好

简单数据类型的操作通常需要更少的CPU周期。 例如， 整型比字符操作代价更低， 因为字符集和校对规则（排序规则） 使字符比较比整型比较更复杂。 这里有两个例子： 一个是应该使用MySQL内建的类型 (2) 而不是字符串来存储日期和时间， 另外一个是应该用整型存储IP地址。   

### 3）尽量避免NULL

很多表都包含可为NULL （空值） 的列， 即使应用程序并不需要保存NULL 也是如此， 这是因为可为NULL 是列的默认属性 。 通常情况下最好指定列为NOT NULL ， 除非真的需要存储NULL 值。  



在为列选择数据类型时， 第一步需要确定合适的大类型： 数字、 字符串、 时间等。 这通常是很简单的， 但是我们会提到一些特殊的不是那么直观的案例。

下一步是选择具体类型。 很多MySQL的数据类型可以存储相同类型的数据， 只是存储的长度和范围不一样、 允许的精度不同， 或者需要的物理空间（磁盘和内存空间） 不同。 相同大类型的不同子类型数据有时也有一些特殊的行为和属性。

例如， **DATETIME 和TIMESAMP** 列都可以存储相同类型的数据： 时间和日期， 精确到秒。

然而TIMESTAMP 只使用DATETIME 一半的存储空间， 并且会根据时区变化， 具有特殊的自动更新能力。 另一方面，TIMESTAMP 允许的时间范围要小得多， 有时候它的特殊能力会成为障碍。  



## 4.1.1、整数类型

Mysql有两种类型的数字： 整数（whole number） 和实数（realnumber） 。   

如果存储整数， 可以使用这几种整数类型： TINYINT，SMALLINT， MEDIUMINT， INT， BIGINT 。 分别使用8， 16， 24， 32， 64位存储空间。 它们可以存储的值的范围从-2（N-1） 到2（N-1） -1， 其中N是存储空间的位数  

MySQL可以为整数类型指定宽度， 例如INT（11） ， 对大多数应用这是没有意义的： 它不会限制值的合法范围， 只是规定了MySQL的一些交互工具（例如MySQL命令行客户端） 用来显示字符的个数。 对于存储和计算来说， INT（1） 和INT（20） 是相同的。  

## 4.1.2、实数类型

因为需要额外的空间和计算开销， 所以应该尽量只在对小数进行精确计算时才使用DECIMAL  







# 4.3 范式和反范式

## 4.3.1、范式的优点和缺点

- 减小数据的冗余性
- 提高效率

- 范式化的更新操作通常比反范式化要快。
- 当数据较好地范式化时， 就只有很少或者没有重复数据， 所以只需
  要修改更少的数据。
- 范式化的表通常更小， 可以更好地放在内存里， 所以执行操作会更
  快  



## 4.3.2 反范式的优点和缺点

范式化设计的缺点是通常需要关联（设计一个关联表关联两个不同的表）

```mysql
mysql> SELECT message_text, user_name
-> FROM message
-> INNER JOIN user ON message.user_id=user.id
-> WHERE user.account_type='premiumv
-> ORDER BY message.published DESC LIMIT 10;
```

反范式化的schema因为所有数据都在一张表中， 可以很好地避免关联。  

**反范式优点：**避免关联，避免了随机I/O，能使用更有效的索引策略

```mysql
mysql> SELECT message_text,user_name
-> FROM user_messages
-> WHERE account_type='premium
-> ORDER BY published DESC
-> LIMIT 10;
```



## 4.3.3 混用范式化和反范式化  

范式化和反范式化的schema各有优劣， 怎么选择最佳的设计？事实是， 完全的范式化和完全的反范式化schema都是实验室里才有的东西： 在真实世界中很少会这么极端地使用。 在实际应用中经常需要混用， 可能使用部分范式化的schema、 缓存表， 以及其他技巧。

最常见的反范式化数据的方法是复制或者缓存， 在不同的表中存储相同的特定列。 在MySQL 5.0和更新版本中， 可以使用触发器更新缓存值， 这使得实现这样的方案变得更简单。  



# 4.5 加快ALTER TABLE操作的速度

### I : 问题引出

  MySQL的ALTER TABLE 操作的性能对大表来说是个大问题。MySQL执行大部分修改表结构操作的方法是用新的结构创建一个空表， 从旧表中查出所有数据插入新表， 然后删除旧表。 这样操作可能需要花费很长时间， 如果内存不足而表又很大， 而且还有很多索引的情况下尤其如此。  

### II :解决方法

一般而言， 大部分ALTER TABLE 操作将导致MySQL服务中断。 我们会展示一些在DDL操作时有用的技巧， 但这是针对一些特殊的场景而言的。 对常见的场景， 能使用的技巧只有两种： 

- “影子拷贝”。 影子拷贝的技巧是用要求的表结构创建一张和源表无关的新表， 然后通过重命名和删表操作交换两张表。
- 先在一台不提供服务的机器上执行ALTER TABLE 操作， 然后和提供服务的主库进行切换；



## 4.5.1 只修改.frm文件  

**不是所有的ALTER TABLE 操作都会引起表重建。**  例如， 有两种方法可以改变或者删除一个列的默认值  



## 4.5.2 快速创建MyISAM索引  





# 4.6 总结

良好的schema设计原则是普遍适用的， 但MySQL有它自己的实现细节要注意。 概括来说， 尽可能保持任何东西小而简单总是好的。MySQL喜欢简单， 需要使用数据库的人应该也同样会喜欢简单的原则：

- 尽量避免过度设计， 例如会导致极其复杂查询的schema设计， 或者
  有很多列的表设计（很多的意思是介于有点多和非常多之间） 。
- 使用小而简单的合适数据类型， 除非真实数据模型中有确切的需
  要， 否则应该尽可能地避免使用NULL 值。
- 尽量使用相同的数据类型存储相似或相关的值， 尤其是要在关联条
  件中使用的列。
- 注意可变长字符串， 其在临时表和排序时可能导致悲观的按最大长
  度分配内存。
- 尽量使用整型定义标识列。
- 避免使用MySQL已经遗弃的特性， 例如指定浮点数的精度， 或者
  整数的显示宽度。
- 小心使用ENUM 和SET 。 虽然它们用起来很方便， 但是不要滥用， 否
  则有时候会变成陷阱。 最好避免使用BIT 。  

范式是好的， 但是反范式（大多数情况下意味着重复数据） 有时也是必需的， 并且能带来好处。  