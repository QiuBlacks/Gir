# 事务的底层实现

# 一、基础知识

## 1、redo log：持久化实现

redo log叫做**重做**日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log）,前者是在内存中，后者在磁盘中。当**事务提交之后**会把所有修改信息都会存到该日志中。

redo log是用来恢复数据的 用于保障，已提交事务的持久化特性

## 2、undo log 

undo log 叫做回滚日志，用于记录数据**被修改前**的信息。他正好跟前面所说的重做日志所记录的相反，重做日志记录数据被修改后的信息。undo log主要记录的是数据的逻辑变化，为了在**发生错误时回滚之前的操作**，需要将之前的操作都记录下来，然后在发生错误时才可以回滚。

## 3、读写锁

共享锁(shared lock),又叫做"读锁" 读锁是可以共享的，或者说多个读请求可以共享一把锁读数据，不会造成阻塞。

排他锁(exclusive lock),又叫做"写锁" 写锁会排斥其他所有获取锁的请求，一直阻塞，直到写入完成释放锁。

**事务的隔离性就是根据读写锁来实现的！**



# 二、事务的底层实现

原子性和持久性是为了要实现数据的可靠性，隔离性管理多个并发读写请求的访问顺序，实现并发处理

- 事务的原子性是通过 undo log 来实现的
- 事务的持久性性是通过 redo log 来实现的
- 事务的隔离性是通过 (读写锁+MVCC)来实现的
- 而事务的终极大 boss **一致性**是通过原子性，持久性，隔离性来实现的！

## 1、原子性



## 2、持久性

## 3、隔离性

### 3.1 READ-UNCOMMITTED(未提交读取)

最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。

因为**读不会加任何锁**，所以写操作在读的过程中修改数据，所以会造成脏读。好处是可以提升并发处理性能，能做到**读写并行**。

- 优点：读写并行，性能高 
- 缺点：造成脏读、幻读或不可重复读

### 1.2 READ-COMMITTED(读取已提交)：

 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。

InnoDB在 READ COMMITTED，使用排它锁,读取数据不加锁而是使用了MVCC机制。或者换句话说他采用了**读写分离机制**。



### 3.3 REPEATABLE-READ(可重复读)： 

对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但**幻读仍有可能发生。**

mysql 有两种机制可以达到这种隔离级别的效果，分别是采用**读写锁以及MVCC**。

**采用读写锁实现**：

![mjjsqo6cz9](https://gitee.com/BlacksJack/picture-bed/raw/master/img/20201120210348.jpeg)

为什么能可重复度？只要没释放读锁，在次读的时候还是可以读到第一次读的数据。

优点：实现起来简单

缺点：无法做到读写并行

**采用MVCC实现**：

![w9ca2pbzpf](https://gitee.com/BlacksJack/picture-bed/raw/master/img/20201120210348.jpeg)

为什么能可重复度？因为多次读取只生成一个版本，读到的自然是相同数据。

优点：读写并行  

缺点：实现的复杂度高

### 3.4 SERIALIZABLE(可串行化)

排他锁

 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。



## 4、一致性

通过回滚，以及恢复，和在并发环境下的隔离做到一致性。



# 参考文章

[图文并茂讲解Mysql事务实现原理](https://cloud.tencent.com/developer/article/1431307)