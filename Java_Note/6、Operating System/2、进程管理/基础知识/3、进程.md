# 进程

# 一、基础知识

## 1、基本介绍

​	是程序的一次执行过程，或是正在运行的一个程序，是一个动态的过程，是**资源分配的最小单位**

## 2、特点

1）结构性 每个进程有一个控制块 PCB。

2）动态性 进程的实质是进程实体的一次执行过程。动态性是进程的**最基本的特征**。

3）并发性 可以与其它进程一道在宏观上同时向前推进。动态性是进程的重要特征。

4）独立性 进程是一个能独立运行 独立分配资源和独立调度的基本单位。

5）异步性（不确定性） 每个进程都以其相对独立、不可预知的速度向前推进。



## 3、PCB组成

- pid表示一个进程的ID资源
- mm_struct表示内存资源
- fs_struct表示文件系统资源
- files_struct表示打开的文件资源
- signal_struct表示信号资源



# 二、进程的生命周期

![image-20201023111245375](https://gitee.com/BlacksJack/picture-bed/raw/master/img/20201023111252.png)

## 1、进程的三种基本状态

### 1.1 就绪(Ready)状态

当进程已分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态称为就绪状态。

### 1.2 执行（Running）状态

当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为执行状态。

### 1.3 阻塞(Blocked)状态（等待）

正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。引起进程阻塞的事件可有多种，例如，等待I/O完成、申请缓冲区不能满足、等待信件(信号)等。



## 2、Linux系统的进程状态

### 2.1 可执行状态：TASK_RUNNING

意味着进程处于可运行状态。并不意味着已经实际分配了CPU。进程可能会一直等到调度器选中它。该状态确保进程可以立即运行，而无需等待外部事件

### 2.2 可中断的睡眠状态：TASK_INTERRUPTIBLE

处于这个状态的进程因为等待某某事件的发生（比如等待socket连接、等待信号量），而被挂起。这些进程的task_struct结构（进程控制块）被放入对应事件的等待队列中。当这些事件发生时（由外部中断触发、或由其他进程触发），对应的等待队列中的一个或多个进程将被唤醒。

### 2.3 不可中断的睡眠状态：TASK_UNINTERRUPTIBLE

进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。不能由外部信号唤醒，只能**由内核亲自唤醒**。

绝大多数情况下，进程处在睡眠状态时，总是应该能够响应异步信号的。否则你将惊奇的发现，kill -9竟然杀不死一个正在睡眠的进程了！于是我们也很好理解，为什么ps命令看到的进程几乎不会出现TASK_UNINTERRUPTIBLE状态，而总是TASK_INTERRUPTIBLE状态。



### 2.4 暂停状态或跟踪状态：TASK_STOPPED or TASK_TRACED

进程暂停执行接受某种处理。如正在接受调试的进程处于这种状态，Linux 使用TASK_STOPPED 宏表示此状态。

### 2.5 退出状态，进程成为僵尸进程：TASK_DEAD - EXIT_ZOMBIE

进程在退出的过程中，处于TASK_DEAD状态。在这个退出过程中，进程占有的所有资源将被回收，除了task_struct结构（以及少数资源）以外。于是进程就只剩下task_struct这么个空壳，故称为僵尸。

之所以保留task_struct，是因为task_struct里面保存了进程的退出码、以及一些统计信息。而其父进程很可能会关心这些信息。父进程可以通过**wait系列的系统调用**（如wait4、waitid）来等待某个或某些子进程的退出，并获取它的退出信息（保存在task_struct里）。然后wait系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉。

当一个进程调用exit()系统调用退出后，它的父进程应该知道该进程的终止。处于TASK_ZOMBIE状态的进程会等待其父进程通知其释放所有的数据结构。

当父/子进程在不同时间点退出时，就可能会出现的细分状态：

#### 1）僵尸状态

 一个进程使用 fork 创建子进程，如果子进程退出后父进程没有调用 wait 或 waitpid 获取子进程的状态信息，并将子进程释放掉。那么子进程的进程描述符仍然保存在系统中，仍然占用进程表，此时进程就处于僵尸状态。 子进程在退出的过程中，内核会给其父进程发送一个信号，通知父进程来“收尸”。

出现僵尸状态可能有两种情况：

 第一种情况，父进程收到通知还没来得及完成收尸，此时正常；

 第二种情况，父进程收尸出现异常，此时，只要父进程不退出，子进程的僵尸状态就一直存在，可以通过**杀死父进程**或者**重启**来解决。

#### 2）孤儿状态

 父进程退出，相应的一个或多个子进程还在运行，那么那些子进程将处于孤儿状态，成为孤儿进程。这些**进程会被托管给特定的进程：**可能是退出进程所在进程组的下一个进程（如果存在的话）；或者是1号进程。所以每个进程、每时每刻都有父进程存在。除非它是1号进程。  

1号进程，pid为1的进程，又称**init进程。**

 linux系统启动后，第一个被创建的用户态进程就是init进程。

它有两项使命：

 1、执行系统初始化脚本，创建一系列的进程（它们都是init进程的子孙）； 

2、在一个死循环中等待其子进程的退出事件，并调用waitid系统调用来完成“收尸”工作； init进程不会被暂停、也不会被杀死（这是由内核来保证的）。它在等待子进程退出的过程中处于TASK_INTERRUPTIBLE状态，“收尸”过程中则处于TASK_RUNNING状态。

#### 3）危害

孤儿进程结束后会被 init 进程善后，并没有危害。

而僵尸进程则会一直占着进程号，操作系统的进程数量有限则会受影响。



## 3、守护进程

Linux系统中的守护进程是一种运行在后台的进程。守护进程，也就是通常说的Daemon进程。它通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。

linux大多数服务器进程就是用守护进程实现的，例如web服务。守护进程常常在系统引导装入时启动，在系统关闭时终止。守护进程最大的特点是运行在后台，与终端无连接，除非特殊情况下，用户不能操作守护进程。



# 三、其他知识点

## 一、进程调度算法:CPU 调度算法

- **先到先服务(FCFS)调度算法** : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
- **短作业优先(SJF)的调度算法** : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度。
- **时间片轮转调度算法** : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。
- **多级反馈队列调度算法** ：前面介绍的几种进程调度的算法都有一定的局限性。如**短进程优先的调度算法，仅照顾了短进程而忽略了长进程** 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前**被公认的一种较好的进程调度算法**，UNIX 操作系统采取的便是这种调度算法。
- **优先级调度** ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何其他资源要求来确定优先级。





## 2、为什么进程切换的开销比线程切换大呢？

进程切换的代价：切换虚拟地址空间，切换内核栈和硬件上下文

线程切换的代价：切换内核栈和硬件上下文	

### 2.1 主要性能消耗：

1）线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的**最显著的性能损耗是将寄存器中的内容切换出**。

2）另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（TLB）会失效，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。而且线程只需要保存线程的上下文（相关寄存器状态和栈的信息）就好了，动作很小



## 3、进程调度时机

进程调度时机：当前运行进程主动放弃处理机和当前运行进程被动放弃处理机。

主动放弃处理机：（1）进程正常终止 运行态->终止态 (2)运行过程中发生异常而终止 运行态->终止态（3）进程主动请求阻塞 如等待I/O 运行态->阻塞态

被动放弃处理机：（1）分给进程的时间片用完 运行态->就绪态 (2)有更紧急的事需要处理 如I/O中断 运行态->就绪态 (3)有更高优先级的进程进入就绪队列 运行态->就绪态 





挂起就绪态

![img](https://gitee.com/BlacksJack/picture-bed/raw/master/img/20200915110343.png)



