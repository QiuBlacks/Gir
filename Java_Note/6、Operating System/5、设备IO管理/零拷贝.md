# 零拷贝

# 一、基础知识

## 1、磁盘访问

磁盘可以说是计算机系统最慢的硬件之一，读写速度相差内存 10 倍以上，所以针对优化磁盘的技术非常的多，比如**零拷贝、直接 I/O、异步 I/O** 等等，这些优化的目的就是为了提高系统的吞吐量。另外操作系统内核中的磁盘高速缓存区PageCache，可以有效的减少磁盘的访问次数。



# 二、DMA技术

 **Direct Memory Access直接内存访问**

## 1、为什么要有 DMA 技术?

在没有 DMA 技术前，I/O 的过程是这样的：

- CPU 发出对应的指令给磁盘控制器，然后返回；
- 磁盘控制器收到指令后，于是就开始准备数据，会把数据放入到磁盘控制器的内部缓冲区中，然后产生一个**中断**；
- CPU 收到中断信号后，停下手头的工作，接着把磁盘控制器的缓冲区的数据一次一个字节地读进自己的寄存器，然后再把寄存器里的数据写入到内存，而在数据传输的期间 CPU 是无法执行其他任务的。

<img src="https://gitee.com/BlacksJack/picture-bed/raw/master/img/20200924150850.webp" alt="img" style="zoom:67%;" />

可以看到，整个数据的传输过程，都要需要 CPU 亲自参与搬运数据的过程，而且这个过程，CPU 是不能做其他事情的。



## 2、DMA技术

### 2.1 基本介绍

在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 **DMA 控制器**，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务。

### 2.2 具体过程

- 用户进程调用 read 方法，向操作系统发出 I/O 请求，请求读取数据到自己的内存缓冲区中，进程进入阻塞状态；
- 操作系统收到请求后，进一步将 I/O 请求发送 DMA，然后让 CPU 执行其他任务；
- DMA 进一步将 I/O 请求发送给磁盘；
- 磁盘收到 DMA 的 I/O 请求，把数据从磁盘读取到磁盘控制器的缓冲区中，当磁盘控制器的缓冲区被读满后，向 DMA 发起中断信号，告知自己缓冲区已满；
- **DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中，此时不占用 CPU，CPU 可以执行其他任务**；
- 当 DMA 读取了足够多的数据，就会发送中断信号给 CPU；
- CPU 收到 DMA 的信号，知道数据已经准备好，于是将数据从内核拷贝到用户空间，系统调用返回；

![img](https://gitee.com/BlacksJack/picture-bed/raw/master/img/20200924151206.webp)

可以看到， 整个数据传输的过程，CPU 不再参与数据搬运的工作，而是全程由 DMA 完成，但是 CPU 在这个过程中也是必不可少的，因为传输什么数据，从哪里传输到哪里，都需要 CPU 来告诉 DMA 控制器。



# 三、文件传输

## 1、传统的文件传输

### 1.1 基本介绍

如果服务端要提供文件传输的功能，我们能想到的最简单的方式是：将**磁盘上的文件读取出来，然后通过网络协议发送给客户端。**

传统 I/O 的工作方式是，数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。

代码通常如下，一般会需要两个系统调用：

```
read(file, tmp_buf, len);
write(socket, tmp_buf, len);
```

代码很简单，虽然就两行代码，但是这里面发生了不少的事情。



### 1.2实现过程

4次上下文切换 + 4次数据拷贝

首先，期间共**发生了 4 次用户态与内核态的上下文切换**，因为发生了两次系统调用，一次是 `read()` ，一次是 `write()`，每次系统调用都得先从用户态切换到内核态，等内核完成任务后，再从内核态切换回用户态。



还**发生了 4 次数据拷贝**，其中两次是 DMA 的拷贝，另外两次则是通过 CPU 拷贝的，下面说一下这个过程：

- 第一次拷贝，把磁盘上的数据拷贝到操作系统内核的缓冲区里，这个拷贝的过程是通过 DMA 搬运的。
- 第二次拷贝，把内核缓冲区的数据拷贝到用户的缓冲区里，于是我们应用程序就可以使用这部分数据了，这个拷贝到过程是由 CPU 完成的。
- 第三次拷贝，把刚才拷贝到用户的缓冲区里的数据，再拷贝到内核的 socket 的缓冲区里，这个过程依然还是由 CPU 搬运的。
- 第四次拷贝，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程又是由 DMA 搬运的。

<img src="https://gitee.com/BlacksJack/picture-bed/raw/master/img/20200924152858.webp" alt="img" style="zoom:67%;" />



所以，**要想提高文件传输的性能，就需要减少「用户态与内核态的上下文切换」和「内存拷贝」的次数**。



## 2、如何优化文件传输的性能？

### 2.1 减少上下文切换到次数

减少系统调用的次数。

### 2.2 减少「数据拷贝」的次数

文件传输的应用场景中，在用户空间我们并不会对数据「再加工」，所以数据实际上可以不用搬运到用户空间，因此**用户的缓冲区是没有必要存在的**。





# 四、零拷贝

## 1、基本介绍

零拷贝技术实现的方式通常有 2 种：

- mmap + write
- sendfile



## 2、mmap + write

用 `mmap()` 替换 `read()` 系统调用函数。

```
buf = mmap(file, len);
write(sockfd, buf, len);
```

`mmap()` 系统调用函数会直接把内核缓冲区里的数据「**映射**」到用户空间，这样，操作系统内核与用户空间就不需要再进行任何的数据拷贝操作。

<img src="https://gitee.com/BlacksJack/picture-bed/raw/master/img/20200924152829.webp" alt="img" style="zoom:67%;" />

具体过程如下：

- 应用进程调用了 `mmap()` 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。接着，应用进程跟操作系统内核「共享」这个缓冲区；
- 应用进程再调用 `write()`，操作系统直接将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态，由 CPU 来搬运数据；
- 最后，把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里，这个过程是由 DMA 搬运的。

我们可以得知，通过使用 `mmap()` 来代替 `read()`， 可以减少一次数据拷贝的过程。

但这还不是最理想的零拷贝，因为仍然需要通过 CPU 把内核缓冲区的数据拷贝到 socket 缓冲区里，而且仍然需要 4 次上下文切换，因为系统调用还是 2 次。



## 3、sendfile

### 3.1 函数形式

```
#include <sys/socket.h>
ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);
```

它的前两个参数分别是目的端和源端的文件描述符，后面两个参数是源端的偏移量和复制数据的长度，返回值是实际复制数据的长度。

### 3.2 实现过程

首先，它可以替代前面的 `read()` 和 `write()` 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销。

其次，该系统调用，可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，这样就只有 2 次上下文切换，和 3 次数据拷贝。如下图：

<img src="https://gitee.com/BlacksJack/picture-bed/raw/master/img/20200924151931.webp" alt="img" style="zoom:67%;" />





## 4、真正的零拷贝

### 4.1 基本定义

零拷贝（Zero-copy）技术：因为我们**没有在内存层面去拷贝数据**，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。

零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，**只需要 2 次上下文切换和数据拷贝次数**，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次**都是由 DMA 来搬运。**

所以，总体来看，**零拷贝技术可以把文件传输的性能提高至少一倍以上**。



### 4.2 实现过程

如果网卡支持 **SG-DMA**（*The Scatter-Gather Direct Memory Access*）技术（和普通的 DMA 有所不同），我们可以进一步减少通过 CPU 把内核缓冲区里的数据拷贝到 socket 缓冲区的过程。

你可以在你的 Linux 系统通过下面这个命令，查看网卡是否支持 scatter-gather 特性：

```
$ ethtool -k eth0 | grep scatter-gather
scatter-gather: on
```

于是，从 Linux 内核 `2.4` 版本开始起，对于支持网卡支持 SG-DMA 技术的情况下， `sendfile()` 系统调用的过程发生了点变化，具体过程如下：

- 第一步，通过 DMA 将磁盘上的数据拷贝到内核缓冲区里；
- 第二步，缓冲区描述符和数据长度传到 socket 缓冲区，这样网卡的 SG-DMA 控制器就可以直接将内核缓存中的数据拷贝到网卡的缓冲区里，此过程不需要将数据从操作系统内核缓冲区拷贝到 socket 缓冲区中，这样就减少了一次数据拷贝；

<img src="https://gitee.com/BlacksJack/picture-bed/raw/master/img/20200924152838.webp" alt="img" style="zoom:67%;" />



## 5、使用零拷贝技术的项目

Kafka 、Nginx 





# 五、大文件传输

## 1、基本介绍

在高并发的场景下，针对大文件的传输的方式，应该使用「**异步 I/O + 直接 I/O**」来替代零拷贝技术。



## 2、实现过程

我们可以发现，异步 I/O 并没有涉及到 PageCache，所以使用异步 I/O 就意味着要绕开 PageCache。

绕开 PageCache 的 I/O 叫**直接 I/O**，使用 PageCache 的 I/O 则叫**缓存 I/O**。通常，对于磁盘，异步 I/O 只支持直接 I/O。

<img src="https://gitee.com/BlacksJack/picture-bed/raw/master/img/20200924152845.webp" alt="img" style="zoom:67%;" />



## 3、直接 I/O 应用场景

- 应用程序已经实现了磁盘数据的缓存，那么可以不需要 PageCache 再次缓存，减少额外的性能损耗。在 MySQL 数据库中，可以通过参数设置开启直接 I/O，默认是不开启；
- 传输大文件的时候，由于大文件难以命中 PageCache 缓存，而且会占满 PageCache 导致「热点」文件无法充分利用缓存，从而增大了性能开销，因此，这时应该使用直接 I/O。





# 六、PageCache： 磁盘高速缓存







# 七、总结

- 传输大文件的时候，使用「异步 I/O + 直接 I/O」；
- 传输小文件的时候，则使用「零拷贝技术」；





# 参考文章

[原来 8 张图，就可以搞懂「零拷贝」了](https://mp.weixin.qq.com/s?__biz=Mzg2NzA4MTkxNQ==&mid=2247490292&idx=2&sn=a48d470b31960b2f47cbc9ef372f300c&chksm=ce405120f937d8364eef27f4f278da6f74711d7c31d8d82bab64a040e6a71adfae87e59a6646&scene=126&sessionid=1600928521&key=892b62220735b7b9bf5a5f514242bcd30e0ea8004295d65c6e114550cf3cb4ef082067bcf499c519d24e881f75f443e75c43fda695bb4c10194c20637cbd62e3b1d11588a34fe7d1e178a48953aa811f46d13c25868af23f4d9451e11c7d0abc784c36f23634d32bc5304116fbd61cf58a841d17272a8bc50505e840e73e40c6&ascene=1&uin=MTg5MjE1NTkyOQ%3D%3D&devicetype=Windows+10+x64&version=63000019&lang=zh_CN&exportkey=AzL0QGKVg5Eue9WWZmnQi6U%3D&pass_ticket=aGnfr%2F9JpQANfnc6sr4MlpVWHpFWPqxPpsB05ONAVIZwaEFOZwn0bznUQDLD7ebW&wx_header=0)





