[TOC]

#  BIO、NIO、AIO

# 一、基本介绍

## 1、基本概念

1、BIO 就是传统的 java.io 包，它是基于流模型实现的，交互的方式是同步、阻塞方式，也就是说在读入输入流或者输出流时，在读写动作完成之前，线程会一直阻塞在那里，它们之间的调用时可靠的线性顺序。它的有点就是代码比较简单、直观；缺点就是 IO 的效率和扩展性很低，容易成为应用性能瓶颈。

2、NIO 是 Java 1.4 引入的 java.nio 包，提供了 Channel、Selector、Buffer 等新的抽象，可以构建多路复用的、同步非阻塞 IO 程序，同时提供了更接近操作系统底层高性能的数据操作方式

3、AIO 是 Java 1.7 之后引入的包，是 NIO 的升级版本，提供了异步非堵塞的 IO 操作方式，所以人们叫它 AIO（Asynchronous IO），异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。



1、BIO：同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时，服务器就启动一个线程来处理，如果这个连接不处理任何事情会造成不必要的线程开销，可以通过线程池机制改善。

2、NIO：同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。

3、AIO：异步非阻塞，服务器实现模式为一个有效请求一个线程，即客户端的I/O请求都是先经过操作系统处理后，再通知服务器应用去启动线程进行处理。

## 2、适用场景分析

- BIO方式适用于**连接数目比较小且固定的架构**，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。

- NIO方式适用于**连接数目多且连接比较短**（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。

- AIO方式使用于**连接数目多且连接比较长**（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。



## 3、区别

BIO：同步阻塞

NIO：同步非阻塞

AIO：异步非阻塞

- **BIO (Blocking I/O):** 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。
- **NIO (Non-blocking/New I/O):** NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 `Socket` 和 `ServerSocket` 相对应的 `SocketChannel` 和 `ServerSocketChannel` 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发
- **AIO (Asynchronous I/O):** AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。



# 二、重要概念

## 1、阻塞IO 和 非阻塞IO

这两个概念是**程序级别**的。主要描述的是程序请求操作系统IO操作后，如果IO资源没有准备好，那么程序该如何处理的问题: 是相对于CPU来说的， 挂起当前线程，前者不能做其他操作只能等待；后者继续执行(并且使用线程一直轮询，直到有IO资源准备好了)

## 2、同步IO 和 非同步IO

这两个概念是**操作系统级别**的。主要描述的是操作系统在收到程序请求IO操作后，如果IO资源没有准备好，该如何响应程序的问题: 前者不响应，直到IO资源准备好以后；后者返回一个标记(好让程序和自己知道以后的数据往哪里通知)，当IO资源准备好以后，再用事件机制返回给程序



## 3、用户进程和内核

![image-20200831091637918](E:/black user/Java/有道云截图/image-20200831091637918.png)



## 4、select和recvfrom

### 4.1 select函数：

会等待多个I/O事件(比如读就绪，写)的任何一个发生，并且只要有一个网络事件发生，select线程就会执行。如果没有任何一个事件发生则阻塞

```c++
#include <sys/select.h>
#include <sys/time.h>

int select(int maxfd,fd_set *readset,fd_set *writeset,fd_set *exceptset,const struct timeval *timeout)
```

参数说明：

- maxfd：需要监视的最大的文件描述符值+1；
- readset：需要检测的可读文件描述符的集合；
- writeset：需要检测的可写文件描述符的集合
- exceptset：需要检测的异常文件描述符的集合
- timeout：超时时间；超时时间有三种情况：
  - NULL：永远等待下去，仅在有一个描述字准备好I/O时才返回；
  - 0：立即返回，仅检测描述符集合的状态，然后立即返回，并不等待外部事件的发生；
  - 特定的时间值： 如果在指定的时间段里没有事件发生，select将超时返回；



fd_set是一个文件描述符集合，可以通过以下宏来操作：

- FD_CLR(inr fd,fd_set* set)：用来清除文件描述符集合set中相关fd的位
- FD_ISSET(int fd,fd_set *set)：用来测试文件描述符集合set中相关fd的位是否为真
- FD_SET（int fd,fd_set*set）：用来设置文件描述符集合set中相关fd的位
- FD_ZERO（fd_set *set）：用来清除文件描述符集合set的全部位



### 4.2 recvfrom

一般用于UDP协议中,但是如果在TCP中connect函数调用后也可以用。用于从（已连接）套接口上接收数据，并捕获数据发送源的地址。

**也就是我们本文中以及书中说的真正的I/O操作。**

















