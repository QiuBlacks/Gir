

# TCP 三次握手和四次挥手

# 一、三次握手

## 1、图解

标志位：

SYN :  请求建立连接

SYN+ ACK ：应答（确认+请求）

ACK ： 确认

seq：请求序列号（服务端、客户端的各不相同）



![截图](https://gitee.com/BlacksJack/picture-bed/raw/master/img/20200910183114.png)

第一次握手：客户端要向服务端发起连接请求，首先客户端随机生成一个起始序列号ISN(比如是100)，那客户端向服务端发送的报文段包含SYN标志位(也就是**SYN=1**)，序列号**seq=x**

第二次握手：服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号(比如是300)。然后给客户端回复一段报文，回复报文包含**SYN和ACK标志(也就是SYN=1,ACK=1)、序列号seq=y、确认号ack=x + 1**(客户端发过来的序列号+1)	

第三次握手：客户端收到服务端的回复后发现ACK=1并且**ack=x + 1**,于是知道服务端已经收到了序列号为**seq = x**的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将**服务端的序列号y**给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK=1)、ack=y + 1 (服务端序列号+1)、seq=x + 1(第一次握手时发送报文是占据一个序列号的，所以这次seq就从101开始，需要注意的是**不携带数据的ACK报文是不占据序列号**的，所以后面第一次正式发送数据时seq还是101)。当服务端收到报文后发现ACK=1并且ack=y + 1，就知道客户端收到服务端序列号为y的报文了，就这样客户端和服务端通过TCP建立了连接



- 客户端–发送带有 SYN 标志的数据包–一次握手–服务端
- 服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端
- 客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端



## 2、为什么要三次握手

主要**防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。**

三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。

举例：已失效的连接请求报文段。

 client发送了第一个连接的请求报文，但是由于网络不好，这个请求没有立即到达服务端，而是在某个网络节点中滞留了，直到某个时间才到达server，如果是两次握手的话，只要server发出确认，新的建立就连接了，但其实这个请求是失效的请求，client是不会理睬server的确认信息，但是server认为新的连接已经建立起了，并一直等待client发来数据，这样，server的很多资源就没白白浪费掉了。

  client发送了第一个连接的请求报文，但是由于网络不好，这个请求没有立即到达服务端，而是在某个网络节点中滞留了，直到某个时间才到达server，本来这已经是一个失效的报文，但是server端接收到这个请求报文后，还是会想client发出确认的报文，表示同意连接。假如不采用三次握手，那么只要server发出确认，新的建立就连接了，但其实这个请求是失效的请求，client是不会理睬server的确认信息，也不会向服务端发送确认的请求，但是server认为新的连接已经建立起了，并一直等待client发来数据，这样，server的很多资源就没白白浪费掉了，采用三次握手就是为了防止这种情况的发生，server会因为收不到确认的报文，就知道client并没有建立连接。这就是三次握手的作用。

 

## 3、为什么要传回第二个 SYN

接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。

因为客户端发送的 syn 可能过了好久才到达服务端,而此时客户端超时重传的 SYN 已 经到达服务端,那么后来的 SYN 就是无效的,如果不发第二个 syn 查询客户端是否有效的 话,服务端就会监听这个延迟到达的请求,造成资源的浪费。所以可以强制发送一个 SYN 询问客户端之前的请求是否有效。

SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。



## 4、传了 SYN,为啥还要传 ACK

双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。





# 二、四次挥手

## 1、图解



![截图2](https://gitee.com/BlacksJack/picture-bed/raw/master/img/20200910183115.png)



断开一个 TCP 连接则需要“四次挥手”：

- 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送，此时发送方的 TCP 连接将从 ESTABLISHED 变成 FIN_WAIT1
- 服务器-收到这个 FIN，它会自动回复一 个 ACK，确认序号为收到的序号加1 。连接状态将从 ESTABLISHED 变成 CLOSE_WAIT，表示被动方在等待进程调用 close 函数关闭连接
- 服务器-关闭与客户端的连接，发送一个FIN给客户端（当被动方进入 CLOSE_WAIT 时，被动方还会继续处理数据，等到进程的 read 函数返回 0 后，应用程序就会调用 close 函数，进而触发内核发送 FIN 报文，此时被动方的连接状态变为 LAST_ACK。）
- 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1（当主动方收到这个 FIN 报文后，内核会回复 ACK 报文给被动方，同时主动方的连接状态由 FIN_WAIT2 变为 TIME_WAIT，要经过**2MSL**(最长报文段寿命的2倍时长)后释放TCP连接，TIME_WAIT 状态的连接才会彻底关闭closed。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。）



## 2、 为什么要四次挥手

为了确保数据能够完成传输。（客户端发送终止请求时，服务端未必发送完所有的数据，所有服务端先发个确实收到信息回去，等数据发送完，再关闭连接，发送FIN）

关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。

可能有人会有疑问，tcp我握手的时候为何ACK(确认)和SYN(建立连接)是一起发送。挥手的时候为什么是分开的时候发送呢.

因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭 SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步挥手。



## 3、TIME_WAIT的作用

通讯双方**主动关闭**的一方进入TIME_WAIT状态

#### 3.1 可靠的终止TCP连接

若处于time_wait的client发送给server的确认报文段丢失的话，server将在此又一次发送FIN报文段，那么client必须处于一个可接收的状态，就是time_wait而不是close状态。

因为MSL是最大报文生存时间，如果在1个MSL时间内自己发送的ACK对方没有收到那就注定收不到了，而且对方肯定还会发送FIN，那么一个FIN发送过来的最长时间也是1个MSL，所以这里要等待2MSL。

#### 3.2 允许老的报文在网络中消逝

防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，**足以保证使本次连接所产生的所有报文段都从网络中消失**。这样新的连接中不会接受到旧连接的请求报文。



## 参考文献

[两张动图-彻底明白TCP的三次握手与四次挥手](https://blog.csdn.net/qzcsu/article/details/72861891)

[重学TCP/IP协议和三次握手四次挥手](https://blog.csdn.net/ThinkWon/article/details/104903925)

[TCP握手和挥手的优化](https://mp.weixin.qq.com/s?__biz=MjM5MjAwODM4MA==&mid=2650757143&idx=2&sn=fd33be8a9d1a715d05734246c7898680&chksm=bea729c489d0a0d2e1f301e2cc8bd8da7fd89c1f042d89e0cc3f2aa1f9434e586750961d74a5&scene=126&sessionid=1593390752&key=e73a462697259ba22448bf6de6886da4e6c7008f39eb3008dd216e6938b24f3d530567310afa99040b2d34d7138d2df9563097d8323cc8cda07150c2b8fdc571e07296c6cc8f3919186425a72dfce156&ascene=1&uin=MTg5MjE1NTkyOQ%3D%3D&devicetype=Windows+10+x64&version=62090523&lang=zh_CN&exportkey=A5zTxii1kakGuuDrJHqJLoc%3D&pass_ticket=m0g1sFZKaKfLU409YyZ4FMqRDjmuZ8oaXaxPY4rzBvE45drgZWCQZjV2IdJ3VNim)

[javaGuide](https://github.com/Snailclimb/JavaGuide/blob/master/docs/network/计算机网络.md)