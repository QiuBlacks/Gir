# I/O模型

参考：https://www.jianshu.com/p/486b0965c296

# 一、基本介绍
## 1、用户态接收内核态数据过程
- 准备数据
- 将数据从内核缓冲区拷贝到进程地址空间

## 2、Linux 五种I/O模型
- 阻塞I/O
- 非阻塞I/O
- I/O复用(select 和 poll)
- 信号驱动I/O
- 异步I/O<br>

其中，前四个被称为同步IO。

## 3、Java 的三大IO

BIO , NIO , AIO



# 二、五种IO模型

## 1、阻塞I/O

![image](https://gitee.com/BlacksJack/picture-bed/raw/master/img/20200910164746.png)

当用户进程调用了 recvfrom() 时，内核进入 IO 的第一个阶段：准备数据（内核需要等待足够多的数据再拷贝），这个过程需要等待，**用户进程会被阻塞**，等内核将数据准备好，然后拷贝到用户地址空间，内核返回结果，用户进程才从阻塞态进入就绪态。

Linux 中，默认情况下所有的 Socket 都是阻塞的。

> 从上述过程可以看出，用户态接收内核态数据的时候，主要有两个过程：内核态获得数据-->将数据从内核态的内存空间中复制到用户态进程的缓冲区中
>

## 2、非阻塞 IO

个人觉得非阻塞 IO还是本质上还是阻塞的

![image](https://gitee.com/BlacksJack/picture-bed/raw/master/img/20200910164751.jpg)<br>

当用户进程发出 recvfrom() 调用时，如果 Kernel 中的数据还没有准备好，那么它并不会阻塞用户进程，而是立刻返回一个 Error。用户进程判断结果是一个 Error 时，它就知道数据还没有准备好，于是它可以再次发送 recvfrom() 调用。一旦 Kernel 中的数据准备好了，并且又再次收到了用户进程的系统调用，那么它马上就将数据拷贝到了用户内存，然后返回

非阻塞 IO 模式下用户进程需要不断地询问内核的数据准备好了没有，如果没有准备好，那么在某些场景中，用户进程可以去做别的事情而不需要一直等待。

Linux 下可以通过设置 Socket 为 non-blocking 模式。



## 3、IO 多路复用
通过一种机制，**一个进程可以监视多个**文件描述符fd（套接字描述符），一旦某个文件描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。这样就不需要每个用户进程不断的询问内核数据准备好了没有<br>

如下图所示，用户态进程采用select的方法，通过select可以等待多个不同类型的消息，如果其中有一个类型的消息准备好，则select会返回信息，然后用户态进程调用recvfrom接收数据。

可以将select复用机制看作是一个描述符集合的管理，进程**通过向这个集合中放入不同的描述符，用来等待不同的消息产生**，然后通过select统一的进行管理，让其可以同时等待这个集合中任意一个事件的产生。

![image](https://gitee.com/BlacksJack/picture-bed/raw/master/img/20200910164805.jpg)

I/O复用和阻塞式I/O很相似，不同的是，I/O复用**等待多类事件**，阻塞式I/O只等待一类事件。

另外，在I/O复用中，会产生两个系统调用（如上图，select和recvfrom），而阻塞式I/O只产生一个系统调用。那么这就涉及到具体的性能问题，当只存在一类事件的时候，使用阻塞式I/O模型的性能会更好，当存在多种不同类型的事件时，I/O复用的性能要好的多，因为阻塞式I/O模型只能监听一类事件，所以这个时候需要使用多线程进行处理。





## 4、信号驱动 IO

在信号驱动式I/O模型中，与阻塞式和非阻塞式有了一个本质的区别，那就是用户态进程不再等待内核态的数据准备好，直接可以去做别的事情。

![image](https://gitee.com/BlacksJack/picture-bed/raw/master/img/20200910164756.jpg)<br>

如上图所示，当需要等待数据的时候，首先用户态会向内核发送一个信号，告诉内核我要什么数据，然后**用户态就不管了，做别的事情去**了，而当内核态中的数据准备好之后，内核立马发给用户态一个信号，说”数据准备好了，快来查收“，用户态进程收到之后，立马调用recvfrom，等待数据从内核空间复制到用户空间，待完成之后recvfrom返回成功指示，用户态进程才处理别的事情。但是在**将数据从内核复制到用户空间这段时间内用户态进程是阻塞的**

## 5、异步 IO

![image](https://gitee.com/BlacksJack/picture-bed/raw/master/img/20200910164800.jpg)<br>

用户进程发起 read() 调用之后，立刻就可以开始去做其它的事。内核收到一个异步 IO read 之后，会立刻返回，不会阻塞用户进程。内核会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，内核会给用户进程发送一个 Signal（信号），告诉它 read() 完成了。**用户进程可以直接从用户内存读取数据**。

**在复制数据到用户空间这个时间段内，用户态进程也是不阻塞的**





## 6、5种IO模型区别

是否阻塞，监听事件的数量，是否异步，内核的两个阶段处理过程

![image-20200920091635413](https://gitee.com/BlacksJack/picture-bed/raw/master/img/20200920091739.png)









# 参考文章

https://mp.weixin.qq.com/s?__biz=Mzg3MjA4MTExMw==&mid=2247484746&idx=1&sn=c0a7f9129d780786cabfcac0a8aa6bb7&source=41#wechat_redirect

[IO模型浅析](https://www.cnblogs.com/yearsj/p/9630440.html)