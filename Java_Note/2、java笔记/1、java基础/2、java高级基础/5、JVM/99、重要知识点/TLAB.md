# TLAB

# 一、基础知识

## 1、问题引出

> 1、堆是线程共享的内存区域，栈是线程独享的内存区域。
>
> 2、堆中主要存放对象实例，栈中主要存放各种基本数据类型、对象的引用。

以上两个结论均不是完全正确的。

**Java对象的内存分配过程是如何保证线程安全的？**

对象的内存分配过程中，主要是对象的引用指向这个内存区域，然后进行初始化操作。

但是，因为堆是全局共享的，因此在同一时间，可能有多个线程在堆上申请空间，那么，在并发场景中，如果**两个线程先后把对象引用指向了同一个堆内存区域，可能会造成线程安全问题！**



## 2、问题解决：TLAB分配

为了解决这个并发问题，对象的内存分配过程就必须进行**同步控制**。但是我们都知道，无论是使用哪种同步方案（实际上虚拟机使用的可能是CAS），都会影响内存的分配效率。

而Java对象的分配是Java中的高频操作，所有，人们想到另外一个办法来提升效率。这里我们重点说一个HotSpot虚拟机的方案：

**每个线程在Java堆中预先分配一小块内存，然后再给对象分配内存的时候，直接在自己这块”私有”内存中分配，当这部分区域用完之后，再分配新的”私有”内存。**

这种方案被称之为**TLAB分配**，即Thread Local Allocation Buffer。这部分Buffer是从堆中划分出来的，但是是本地线程独享的。



# 二、TLAB

## 1、基本介绍

TLAB是虚拟机在**堆内存的eden**划分出来的一块私有的缓冲区，是线程专属的，**每个TLAB只占伊甸园区的1%**。

在虚拟机的TLAB功能启动的情况下，在线程初始化时，虚拟机会为每个线程分配一块TLAB空间，只给当前线程使用，这样每个线程都单独拥有一个空间，如果需要分配内存，就在自己的空间上分配，这样就不存在竞争的情况，可以大大提升分配效率。

所以说，因为有了TLAB技术，**堆内存并不是完完全全的线程共享，其eden区域中还是有一部分空间是分配给线程独享的。**

这里值得注意的是，我们说TLAB是线程独享的，但是只是在“分配”这个动作上是线程独享的，至于在读取、垃圾回收等动作上都是线程共享的。而且在使用上也没有什么区别。|



a.尽管不是所有的对象都在TLAB分配内存，但是JVM会优先在TLAB为对象分配内存；

b.当TLAB内存空间不足时，会采用**同步加锁机制**在伊甸园其他区域分配内存，确保数据操作的原子性。



### **TLAB带来的问题**

虽然在一定程度上，TLAB大大的提升了对象的分配速度，但是TLAB并不是就没有任何问题的。

前面我们说过，因为TLAB内存区域并不是很大，所以，有可能会经常出现不够的情况。在《实战Java虚拟机》中有这样一个例子：

比如一个线程的TLAB空间有100KB，其中已经使用了80KB，当需要再分配一个30KB的对象时，就无法直接在TLAB中分配，遇到这种情况时，有两种处理方案：

1、如果一个对象需要的空间大小超过TLAB中剩余的空间大小，则直接在堆内存中对该对象进行内存分配。

2、如果一个对象需要的空间大小超过TLAB中剩余的空间大小，则废弃当前TLAB，重新申请TLAB空间再次进行内存分配。

以上两个方案各有利弊，如果采用方案1，那么就可能存在着一种极端情况，就是TLAB只剩下1KB，就会导致后续需要分配的大多数对象都需要在堆内存直接分配。

如果采用方案2，也有可能存在频繁废弃TLAB，频繁申请TLAB的情况，而我们知道，虽然在TLAB上分配内存是线程独享的，但是TLAB内存自己从堆中划分出来的过程确实可能存在冲突的，所以，TLAB的分配过程其实也是需要并发控制的。而频繁的TLAB分配就失去了使用TLAB的意义。

为了解决这两个方案存在的问题，虚拟机定义了一个refill_waste的值，这个值可以翻译为“最大浪费空间”。

当请求分配的内存大于refill_waste的时候，会选择在堆内存中分配。若小于refill_waste值，则会废弃当前TLAB，重新创建TLAB进行对象内存分配。

前面的例子中，TLAB总空间100KB，使用了80KB，剩余20KB，如果设置的refill_waste的值为25KB，那么如果新对象的内存大于25KB，则直接堆内存分配，如果小于25KB，则会废弃掉之前的那个TLAB，重新分配一个TLAB空间，给新对象分配内存。



## 参考文章

https://mp.weixin.qq.com/s/Wws24Fhg1nH4dHvtcFYi2g





