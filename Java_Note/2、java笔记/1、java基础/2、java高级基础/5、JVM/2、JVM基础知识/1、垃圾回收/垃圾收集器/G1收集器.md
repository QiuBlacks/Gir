# G1收集器（Garbage-First GC）

## 一、基本介绍

### 1、Garbage-First GC

G1使用了分区和分代算法来划分堆内存空间，此时堆内存不止拥有固定的一个Eden区、两个Survivor区、一个Old区，而是变成可多个变化的Eden区、Survivor区和Old区，以及多个Humongous区。

当执行垃圾回收时，虚拟机可有计划的避免在整个堆内存上进行垃圾回收。G1可以根据各个region的垃圾堆积的价值大小，即回收所获得的空间大小以及回收所需时间的经验值，在后台维护一个相应的**优先列表**。在具体执行垃圾回收时，**优先回收价值最大的region**，即所谓的垃圾优先（Garbage First）。

### 2、特点

- **并行性和并发性**
- **分代GC**：与之前回收器不同，其他回收器，它们要么工作在年轻代要么工作在老年代。G1可以同时兼顾年轻代与老年代。
- **分区**
- **空间整理**：G1在回收过程中，会进行适当的对象移动，不像CMS，只是简单的标记清除，在若干次GC后CMS必须进行一次碎片整理，G1在每次回收时都会有效的复制对象，减少空间碎片。
- **可预见性**：由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收范围，因此对于全局停顿也能得到更好的控制。

### 3、G1过程

- **年轻代GC（Young GC）**
- **老年代并发标记过程（Concurrent Marking）**
- **混合回收（Mixed GC）**
- **（如果需要）进行Full GC**





## 二、特点详解

### 1、并发和并行

**并发**是指在垃圾回收期间，Java虚拟机可以使用多个线程同时执行回收操作，这样有效的利用了设备的多核能力，提升了垃圾回收的效率。但在并发回收阶段，用户线程会触发STW。

**并行**是指G1拥有和应用程序交替执行的能力，部分工作可以和应用程序同时执行。因此，一般不会在整个回收阶段发生完全阻塞应用程序的情况。



### 2、分代收集

G1仍然遵循了分代收集理论，它将堆内存划分为很多物理上不连续的region，使用不同的region来表示Eden区、Survivor区、Old区。但此时Eden区、Survivor区和Old区的数量不再和之前使用分代收集的并发回收器一致，它们的**数量不再是固定的，同时不要求内存空间都是连续的。**

由于它将堆内存空间划分为多个新生代和老年代，同时兼顾了两代空间的垃圾回收。因此，**G1不再像之前的回收器只能单独执行某一代的回收操作，而是可以同时工作在新生代和老年代**。



### 3、分区

<img src="https://gitee.com/BlacksJack/picture-bed/raw/master/img/20200910165312.png" alt="image-20200804161636992" style="zoom:67%;" />

它将堆内存划分为2048个物理上不连续的独立的region，使用不同的region来表示Eden区、Survivor区、Old区。不同的region的大小可根据对空间的实际大小确定，通常空间在1M~32M，且为2的次幂。一旦确定了每个region的大小，它们在JVM的整个生命周期中就不再变化，而且每个region在具体的某次分配中只能但当一个角色。

不同的region不仅要求在物理存储上不必连续，而且它们的分配也是动态的，某个region具体作为哪一种区间是随着垃圾回收动作不断变化的，这样动态分的特点实现了逻辑上的连续。

另外还增加了一个**Humongous**区，它用来**存放创建的短期使用的大对象**。当需保存的对象大小超过了0.5个region时，JVM会将其直接放到Humongous区中。如果一个Humongous区存放不下，则会找连续的Humongous区。如果连续的Humongous区不存在，则会出发Full GC。



### 4、 空间整合

G1将内存划分为多个region，内存回收便以**region**为基础单位进行。**region之间使用的是复制算法，但整体上实际可看做是标记-整理算法，因此，回收操作可以避免内存碎片的产生。**这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发Full GC。尤其是在Java对空间非常大时，G1相对于其他的垃圾回收器优势更加明显。



### 5、可预测的停顿时间

G1除了追求低停顿时间外，还可建立可预测的停顿时间模型，它允许程序通过参数指定在一个长度为M毫秒的时间片段内内执行回收操作，这样就要求收集器消耗在垃圾回收上的时间不得超过N毫秒。

由于G1将堆内存划分为了多个region，使得回收器在执行垃圾回收操作的时间，不仅可以只针对于部分区域进行回收外，还可以根据**维护的优先列表**优先回收价值较高的区域。因此，这样的操作方式可以预测停顿时间的范围，同时保证了G1在有限的时间内获取尽可能高的收集效率。



## 三、G1过程详解









## 参考文章

[Java虚拟机 -- 垃圾回收器（中篇）](https://blog.csdn.net/Forlogen/article/details/106975432)

[Java GC G1 详解](https://blog.csdn.net/jiankunking/article/details/85626279)

https://blog.csdn.net/youyou1543724847/article/details/52728244<br>


