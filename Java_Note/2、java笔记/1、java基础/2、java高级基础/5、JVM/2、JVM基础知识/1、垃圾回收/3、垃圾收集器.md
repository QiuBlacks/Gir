

[TOC]



# 垃圾收集器（垃圾算法的具体实现）

&emsp;&emsp;垃圾收集算法是方法论，垃圾收集器是具体实现。JVM规范对于垃圾收集器的应该如何实现没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器差别较大



## 一、几种垃圾收集器：

- Serial收集器： 单线程的收集器，收集垃圾时，必须stop the world，使用复制算法。
- ParNew收集器： Serial收集器的多线程版本，也需要stop the world，复制算法。
- Parallel Scavenge收集器： 新生代收集器，复制算法的收集器，并发的多线程收集器，目标是达到一个可控的吞吐量。如果虚拟机总共运行100分钟，其中垃圾花掉1分钟，吞吐量就是99%。
- Serial Old收集器： 是Serial收集器的老年代版本，单线程收集器，使用标记整理算法。
- Parallel Old收集器： 是Parallel Scavenge收集器的老年代版本，使用多线程，标记-整理算法。
- CMS(Concurrent Mark Sweep) 收集器： 是一种以获得最短回收停顿时间为目标的收集器，标记清除算法，运作过程：初始标记，并发标记，重新标记，并发清除，收集结束会产生大量空间碎片。
- G1收集器： 标记整理算法实现，运作流程主要包括以下：初始标记，并发标记，最终标记，筛选标记。不会产生空间碎片，可以精确地控制停顿。
- 

## 二、G1收集器（(Garbage-First)）

参考：https://blog.csdn.net/youyou1543724847/article/details/52728244<br>
https://blog.csdn.net/jiankunking/article/details/85626279





## 三、CMS收集器（Concurrent Mark Sweep）

### 1、介绍

是一种以获取最短回收停顿时间为目标的收集器，它是基于“标记-清除”算法实现的，并且常见的应用场景是互联网站或者B/S系统的服务端上的Java应用



### 2、算法过程

- **初始标记**：标记GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。
- **并发标记**：进行GC Roots Tracing的过程，在整个过程中耗时最长。

-  **并发预处理**：工作还是标记，与3.4的重标记功能相似。重标记需要STW（Stop The World），因此重标记的工作尽可能多的在并发阶段完成来减少STW的时间。

   此阶段标记从**新生代晋升的对象**、**新分配到老年代的对象**以及在**并发阶段被修改了的对象**。

- **重标记**：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要“Stop The World”。

- **并发清除**：用户线程被重新激活，同时清理那些无效的对象。

- **重置**： CMS清除内部状态，为下次回收做准备



### 3、缺陷

#### **1）垃圾碎片的问题**

​	我们都知道CMS是使用的是**标记-清除**算法的，所以不可避免的就是会出现垃圾碎片的问题

#### 2）remark阶段停顿时间长

**一般CMS的GC耗时80%都在remark阶段，remark阶段停顿时间会很长**，在CMS的这四个主要的阶段中，最费时间的就是重新标记阶段

#### 3）**concurrent mode failure**

这个异常发生在cms正在回收的时候。执行CMS GC的过程中，由于垃圾回收阶段用户线程仍在执行，必需预留出内存空间给用户线程使用。因此不能像其他回收器那样，等到老年代满了再进行GC。当年轻带空间满了，执行ygc时，需要将存活的对象放入到老年代，而此时老年代空间不足，这时CMS还没有机会回收老年带产生的，或者在做Minor GC的时候，新生代救助空间放不下，需要放入老年代，而老年代也放不下而产生的

#### 4）**promotion failed**：

这个问题是指，在进行Minor GC时，Survivor空间不足，对象只能放入老年代，而此时老年代也放不下造成的，多数是由于老年代有足够的空闲空间，但是由于碎片较多，新生代要转移到老年带的对象比较大,找不到一段连续区域存放这个对象导致的。



### 4、解决方法

#### 1）垃圾碎片的问题

针对这个问题，这时候我们需要用到这个参数：`-XX:CMSFullGCsBeforeCompaction=n` 意思是说在上一次CMS并发GC执行过后，到底还要再执行多少次不压缩的`full GC` 后才会做一次压缩。

默认是0，也就是在默认配置下每次CMS GC顶不住了而要转入full GC的时候都会做压缩。



#### 2）**remark阶段停顿时间会很长的问题**：

解决这个问题巨简单，加入`-XX:+CMSScavengeBeforeRemark`。在执行remark操作之前先做一次`Young GC`，目的在于减少年轻代对老年代的无效引用，降低remark时的开销。



#### 3）**concurrent mode failure**

解决这个问题其实很简单，只需要设置两个参数即可

`-XX:+UseCMSInitiatingOccupancyOnly `：CMS会根据历史记录，预测老年代还需要多久填满及进行一次回收所需要的时间。在老年代空间用完之前，CMS可以根据自己的预测自动执行垃圾回收。

`-XX:CMSInitiatingOccupancyFraction=60`：是指设定CMS在对内存占用率达到60%的时候开始GC。

为什么设置这两个参数呢？由于在垃圾收集阶段用户线程还需要运行，那也就还需要**预留有足够的内存空间给用户线程使用**，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集。

当然也不能设置过高，比如90%，这时候虽然GC次数少，但是，却会导致用于用户线程空间小，效率不高，太低10%，你自己想想会怎么样，体会体会！



### 参考：

[详解CMS垃圾回收机制](https://www.cnblogs.com/Leo_wl/p/5393300.html)





