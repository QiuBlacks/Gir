

[TOC]





--------------------------------------------------------------------------------

# 一、基本介绍

## 1、最基本的问题

&emsp;&emsp;如果确定某个对象是“垃圾”？既然垃圾收集器的任务是回收垃圾对象所占的空间供新的对象使用，那么垃圾收集器如何确定某个对象是“垃圾”？

———即通过什么方法判断一个对象可以被回收了

## 2、分类

&emsp;&emsp;不同的对象引用类型， GC会采用不同的方法进行回收，JVM对象的引用分为了四种类型：

- 强引用：默认情况下，new对象采用的均为强引用（这个对象的实例没有其他对象引用，GC时才会被回收）。
- 弱引用：在GC时一定会被GC回收。
- 软引用：软引用是Java中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被GC）。

```java
SoftReference<String> softRef=new SoftReference<String>(str);     // 软引用
```

- 虚引用：由于虚引用只是用来得知对象是否被GC。





# 二、判断垃圾算法

## 1.引用计数法(java不采用)

### 1）算法思路

&emsp;&emsp;　在java中是通过引用来和对象进行关联的，也就是说如果要操作对象，必须通过引用来进行。那么很显然一个简单的办法就是通过引用计数来判断一个对象是否可以被回收。不失一般性，如果一个对象没有任何引用与之关联，则说明该对象基本不太可能在其他地方被使用到，那么这个对象就成为可被回收的对象了。

### 2）算法分析

&emsp;&emsp;引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。

### 3）优点

&emsp;&emsp;实现简单，而且效率较高

### 4）缺点：

&emsp;&emsp;无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.

### 5）缺点的代码分析

```java
public class Main {
    public static void main(String[] args) {
        MyObject object1 = new MyObject();
        MyObject object2 = new MyObject();
         
        object1.object = object2;
        object2.object = object1;
         
        object1 = null;
        object2 = null;
    }
}
 
class MyObject{
    public Object object = null;
}
```

&emsp;&emsp;最后面两句将object1和object2赋值为null，也就是说object1和object2指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数都不为0，那么垃圾收集器就永远不会回收它们。


## 2、可达性分析法（Java采用）


### ![20170713090159517 (1)](E:\black user\Java\有道云截图\20170713090159517 (1).png)

### 1）基本思想

&emsp;&emsp;通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为“引用链”，当一个对象到 GC Roots 没有任何的引用链相连时(从 GC Roots 到这个对象不可达)时，证明此对象不可用。<br>
&emsp;&emsp;不过要注意的是被判定为==不可达的对象不一定就会成为可回收对象==。被判定为不可达的对象要成为可回收对象必须至少经历==两次标记==过程，如果在这两次标记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。


### 2)在Java语言中，可作为GC Roots的对象包含以下几种：

- 本地方法栈中(Native方法)引用的对象			(可以理解为:引用Native方法的所有对象)
- 虚拟机栈(栈帧中的本地变量表)中引用的对象。		(可以理解为:引用栈帧中的本地变量表的所有对象)
- 方法区中静态属性引用的对象 					(可以理解为:引用方法区该静态属性的所有对象)
- 方法区中常量引用的对象						(可以理解为:引用方法区中常量的所有对象)



### 3)finalize()方法最终判定对象是否存活

&emsp;&emsp;如果对象在进行可行性分析后发现没有与GC Roots相连的引用链，也并非是 “非死不可” 的。

#### 经历的步骤:

#### i. 第一次标记并进行一次筛选。

&emsp;&emsp;标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链;<br>
&emsp;&emsp;筛选的条件是此对象是否有必要执行finalize()方法。
<br>&emsp;&emsp;当对象没有覆盖finalize方法，或者finzlize方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，对象被回收。

#### ii:.第二次标记

&emsp;&emsp;如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为：F-Queue的队列之中，并在稍后由一条虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。<br>
&emsp;&emsp;这样做的原因是：如果一个对象finalize（）方法中执行缓慢，或者发生死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。<br>
  &emsp;&emsp;	  Finalize（）方法是对象脱逃死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize（）中成功拯救自己----只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。





## 3、常见的将对象判定为可回收对象的情况：

### 　1）显示地将某个引用赋值为null或者将已经指向某个对象的引用指向新的对象

比如下面的代码：

```java
Object obj = new Object();
obj = null;
Object obj1 = new Object();
Object obj2 = new Object();
obj1 = obj2;
```


### 2）局部引用所指向的对象

比如下面这段代码：

```java
void fun() {
 
.....
    for(int i=0;i<10;i++) {
        Object obj = new Object();
        System.out.println(obj.getClass());
    }   
}
```


&emsp;&emsp;循环每执行完一次，生成的Object对象都会成为可回收的对象。

### 　3）只有弱引用与其关联的对象，比如：

```java
WeakReference<String> wr = new WeakReference<String>(new String("world"));
```

