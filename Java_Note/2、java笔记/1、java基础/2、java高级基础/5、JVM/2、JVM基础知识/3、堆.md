# 堆

--------------------------------------------------------------------------------
# 一、基本介绍
## 1、特点
&emsp;&emsp;所有线程共享；<br>
&emsp;&emsp;存放几乎所有的对象实例以及数组的区域；可以认为Java中所有通过new创建的对象的内存都在此分配；<br>
&emsp;&emsp;此区域是GC垃圾回收机制的主要操作区域。

## 2、组成结构
- 堆=新生代+老年代		
- 新生代 = Eden + S0 + S1	<br>

![image-20200520103512653](E:\black user\Java\有道云截图\image-20200520103512653.png)



## 3、默认参数

&emsp;&emsp;Survivor区中的对象被复制次数为15（超过这个数就会进行GC)

```java
堆=新生代+老年代		 =1：2
新生代 = Eden + S0 + S1	=8：1：1
```



## 4、**minor gc和full gc发生的时机**

Minor GC（Young GC）触发条件：当Eden区满时，触发Minor GC。

Full GC触发条件：
               （1）调用System.gc时，系统建议执行Full GC，但是不必然执行
               （2）老年代空间不足
               （3）方法区(1.8之后改为元空间)空间不足
               （4）创建大对象，比如数组，通过Minor GC后，进入老年代的平均大小大于老年代的可用内存
               （5）由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。


## 5、异常

&emsp;&emsp;堆所在的物理内存区间可以是不连续的，只要逻辑连续就可以。实现时既可以是固定大小，也可以是可扩展的。如果堆无法扩展时，就会抛出OutOfMemoryError。



# 二、

## 1、垃圾回收流程（GC）
&emsp;&emsp;对新生代的对象的收集称为==minor GC==；对旧生代的对象的收集称为==Full GC==；<br>

&emsp;&emsp;新生代中的对象“朝生夕死”，每次GC时都会有大量对象死去，少量存活，使用复制算法。新生代又分为Eden区和Survivor区（Survivor from、Survivor to），大小比例默认为==8:1:1==。<br>
&emsp;&emsp;老年代中的对象因为对象存活率高、没有额外空间进行分配担保，就使用标记-清除或标记-整理算法。<br>
&emsp;&emsp;新产生的对象优先进去Eden区，当Eden区满了之后再使用Survivor from，当Survivor from 也满了之后就进行Minor GC（新生代GC），将Eden和Survivor from中存活的对象copy进入Survivor to，然后清空Eden和Survivor from，这个时候原来的Survivor from成了新的Survivor to，原来的Survivor to成了新的Survivor from。复制的时候，如果Survivor to 无法容纳全部存活的对象，则根据老年代的分配担保（类似于银行的贷款担保）将对象copy进去老年代，如果老年代也无法容纳，则进行Full GC（老年代GC）。<br>
&emsp;&emsp;大对象直接进入老年代：JVM中有个参数配置-XX:PretenureSizeThreshold，令大于这个设置值的对象直接进入老年代，目的是为了避免在Eden和Survivor区之间发生大量的内存复制。<br>
&emsp;&emsp;长期存活的对象进入老年代：JVM给每个对象定义一个对象年龄计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳，将被移入Survivor并且年龄设定为1。每熬过一次Minor GC，年龄就加1，当他的年龄到一定程度（默认==为15==岁，可以通过XX:MaxTenuringThreshold来设定），就会移入老年代。但是JVM并不是永远要求年龄必须达到最大年龄才会晋升老年代，如果Survivor 空间中相同年龄（如年龄为x）所有对象大小的总和大于Survivor的一半，年龄大于等于x的所有对象直接进入老年代，无需等到最大年龄要求。



## 2、为什么要分为Eden和Survivor?为什么要设置两个Survivor区？

1）如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC.老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多,增加了内存使用率<br>
&emsp;&emsp;2）Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。<br>
&emsp;&emsp;3）设置两个Survivor区最大的好处就是==解决了碎片化==，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1<br>
&emsp;&emsp;（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）













