

[TOC]



# JMM(Java 内存模型)

---
# 一、基本介绍
## 1、基本概念
### 1.1 JMM

Java ==线程之间的通信由 Java 内存模型（本文简称为 JMM）控制==，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。

**JVM将内存组织为主内存和工作内存两个部分。**



### 1.2 主内存

主内存主要包括本地方法区和堆。

### 1.3 工作内存

每个线程都有一个工作内存，工作内存中主要包括两个部分，一个是属于该线程私有的栈和对主存部分变量拷贝的寄存器(包括程序计数器PC和cup工作的高速缓存区)。

（工作）本地内存是 JMM 的一==个抽象概念==，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。其存储了该线程以读 / 写共享变量的副本。

### 1.4 主内存和工作内存的关系

从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地（工作）内存，本地内存中存储了该线程以读 / 写共享变量的副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。

即：

- 线程对变量的所有操作都必须在自己的工作内存中进行，而不能直接读写主内存中的变量。

- 不同的线程之间无法直接访问对方工作内存中的变量。

- 线程间变量值的传递均需要通过主内存来完成。

  

## 2、Java 内存模型的抽象示意图

不同线程之间无法直接访问对方工作内存中的变量，线程间的通信一般有两种方式进行，一是通过消息传递，二是共享内存。Java 线程间的通信采用的是**共享内存**方式，线程、主内存和工作内存的交互关系如下图所示：

<img src="E:/black user/Java/有道云截图/image-20200618214045805.png" alt="image-20200618214045805" style="zoom:80%;" />

&emsp;&emsp;从上图来看，线程 A 与线程 B 之间如要通信的话，必须要经历下面 2 个步骤： 
- 首先，线程 A 把本地内存 A 中更新过的共享变量刷新到主内存中去。
- 然后，线程 B 到主内存中去读取线程 A 之前已更新过的共享变量。

&emsp;&emsp;JMM 通过控制主内存与每个线程的本地内存之间的交互，来为 java 程序员提供内存可见性保证









## 三、Java解决并发问题的: JMM(Java内存模型)

### 1、核心知识点

JMM本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。具体来说，这些方法包括：

- volatile、synchronized 和 final 三个关键字<br>
- Happens-Before 规则<br>

### 2、可见性，有序性，原子性

#### 1）原子性

```
//语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中 
x = 10; 
//语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存；
// 虽然读取x的值以及 将x的值写入工作内存这2个操作都是原子性操作，但是合起来就不是原子性操作了。
y = x; 
//语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。
x++;
//语句4： 同语句3
x = x + 1;
```


&emsp;&emsp;Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。

#### 2）可见性

&emsp;&emsp;对于可见性，Java提供了volatile关键字来保证可见性。<br>
&emsp;&emsp;当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。<br>
&emsp;&emsp;而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。<br>
&emsp;&emsp;另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。

#### 3）有序性

&emsp;&emsp;　在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。<br>
&emsp;&emsp;在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。<br>
&emsp;&emsp;另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。

### 3、happens-before原则

J&emsp;&emsp;ava内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 **happens-before原则**。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。

#### 1)happens-before原则（先行发生原则）：

- 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
- 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作
- volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
- 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
- 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作
- 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
- 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
- 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始



## 四、内存模型

计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。<br>
　　也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。



## 五、 jvm和jmm之间的关系

jmm中的主内存、工作内存与jvm中的Java堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，**主内存主要对应于Java堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域**。从更低层次上说，主内存就直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（甚至是硬件系统本身的优化措施）可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问读写的是工作内存。









