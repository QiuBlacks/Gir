# 方法区（运行时常量池）
--------------------------------------------------------------------------------

参考:https://blog.csdn.net/sugar_rainbow/article/details/68150249<br>
https://blog.csdn.net/wangtaomtk/article/details/52267548

# 一、基本介绍
## 1、方法区
&emsp;&emsp;
所有定义的方法的信息都保存在该区域，此区域属于共享区间。<br>
&emsp;&emsp;存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据等。回收目标主要是常量池的回收和类型的卸载，各==线程共享==

## 2、永久代（Permanent Generation）
&emsp;&emsp;永久代是 HotSpot 虚拟机在 JDK7 及以前对方法区的具体实现，而永久代也在 heap 中(但注意，其它虚拟机并没有永久代，这是 HotSpot 虚拟机特有的)。

![截图](E:\black user\Java\有道云截图\截图.png)

&emsp;&emsp;在 JDK1.7 中，移除永久代的工作就已经开始了，原先存储在永久代的部分数据转移到了Java heap 或者 native memory，但永久代仍存在于 JDK1.7 中，并没完全移除。移除工作主要包括下面三点：
符号引用(Symbolic Reference)转移到了native memory
Interned Strings转移到了heap
静态变量从instanceKlass对象(PermGen内)末尾转移到了java.lang.Class对象(heap内)的末尾

## 3、元空间(metaspace)

&emsp;&emsp;从 JDK 8 开始的 HotSpot 虚拟机完全移除了 PermGen，改为在 native memory 里存放这些元数据。新的用于存放元数据的内存空间叫做 Metaspace。



![元空间](E:\black user\Java\有道云截图\元空间.png)



### 取消永久代主要有以下几点原因：
&emsp;&emsp;字符串存在永久代中，容易出现性能问题和内存溢出永久代会为 GC 带来不必要的复杂度，并且回收效率偏低

​	便于将 HotSpot 与 JRockit 合二为一(JRockit 中并没有永久代)



# 二、运行时常量池
## 1、 Class文件中的常量池
 		Class常量池主要用于存放两大类常量：字面量和符号引用量
参考一下dalao的博客:https://blog.csdn.net/wangtaomtk/article/details/52267548<br>



![截图1](E:\black user\Java\有道云截图\截图1.png)



## 2、运行时常量池
### 1）基本概念
&emsp;&emsp;Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是运行时常量池。<br>
&emsp;&emsp;用于存放编译器生成的各种字面常量和符号引用，这部分内容被类加载后进入方法区的运行时常量池中存放

### 2）动态性
&emsp;&emsp;运行时常量池相对于CLass文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入CLass文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。

### 3） 常量池的好处
&emsp;&emsp;常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。

## 3、String.intern()
&emsp;&emsp;检查字符串常量池中是否存在String并返回<br>
&emsp;&emsp;这样做主要是为了避免在堆中不断地创建新的字符串对象


# 三、String常量池（特殊）

参考:https://blog.csdn.net/sugar_rainbow/article/details/68150249




