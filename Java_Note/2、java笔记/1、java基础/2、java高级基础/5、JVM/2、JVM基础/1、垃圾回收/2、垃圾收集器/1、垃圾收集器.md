

# 垃圾收集器（垃圾算法的具体实现）

垃圾收集算法是方法论，垃圾收集器是具体实现。JVM规范对于垃圾收集器的应该如何实现没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器差别较大



## 一、基本介绍

### 1、 10种垃圾收集器（至JVM13）

- Serial收集器： 单线程的收集器，收集垃圾时，必须stop the world，使用复制算法。
- ParNew收集器： Serial收集器的**多线程版**本，也需要stop the world，复制算法。
- Parallel Scavenge收集器： 新生代收集器，复制算法的收集器，并发的多线程收集器，目标是达到一个可控的吞吐量。如果虚拟机总共运行100分钟，其中垃圾花掉1分钟，吞吐量就是99%。
- Serial Old收集器： 是Serial收集器的老年代版本，**单线程**收集器，使用标记整理算法。
- Parallel Old收集器： 是Parallel Scavenge收集器的老年代版本，使用多线程，标记-整理算法。
- CMS(Concurrent Mark Sweep) 收集器： 是一种以获得最短回收停顿时间为目标的收集器，标记清除算法，运作过程：初始标记，并发标记，重新标记，并发清除，收集结束会产生大量空间碎片。
- G1收集器： 标记整理算法实现，运作流程主要包括以下：初始标记，并发标记，最终标记，筛选标记。不会产生空间碎片，可以精确地控制停顿。
- ZGC
- Shenandoah



分代和不分代：

<img src="https://gitee.com/BlacksJack/picture-bed/raw/master/img/20200910165318.png" alt="image-20200615195923743" style="zoom:80%;" />



垃圾回收器的发展路线，是随着内存越来越大的过程而演进							
		从分代算法演化到不分代算法
			Serial算法 			几十兆
			Parallel算法 		几个G
			CMS				 	几十个G  - 承上启下，开始并发回收 -



| GC           | 分类           | 作用位置 | 算法                    | 特点         | 使用场景                     |
| ------------ | -------------- | -------- | ----------------------- | ------------ | ---------------------------- |
| Serial       | 串行运行       | 新生代   | 复制算法                | 响应速度优先 | 单CPU的Client模式            |
| ParNew       | 并行运行       | 新生代   | 复制算法                | 响应速度优先 | 多CPU的Server模式            |
| Parallel     | 并行运行       | 新生代   | 复制算法                | 吞吐量优先   | 与后台运算不需太多交互的场景 |
| Serial Old   | 串行运行       | 老年代   | 标记-整理算法           | 响应速度优先 | 单CPU的Client模式            |
| Parallel Old | 并行运行       | 老年代   | 标记-整理算法           | 吞吐量优先   | 与后台运算不需太多交互的场景 |
| CMS          | 并发运行       | 老年代   | 标记-整理算法           | 响应速度优先 | 互联网或B/S业务              |
| G1           | 并发、并行运行 | 整堆     | 标记-整理算法、复制算法 | 响应速度优先 | 面向服务端应用               |



### 2. 性能指标

- **吞吐量**：运行用户程序的时间占总运行时间的比例
- 垃圾收集开销：垃圾收集所用时间与总运行时间的比例
- **暂停时间**：执行垃圾收集时，程序的工作线程被暂停的时间
- 收集频率：相对于应用程序的执行，收集操作发生的频率
- 内存占用：Java堆区所占内存的大小

其中最为重要的就是**平衡吞吐量和暂停时间**。如果以吞吐量优先，那么必然需要降低内存回收的执行效率，但这样会导致需要更长的暂停时间来执行内存回收；如果以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，就只能频繁的执行内存回收，这又引起了年轻代内存的缩减和导致程序吞吐量下降。

一般来说，在最大吞吐量优先的情况下，降低停顿时间。

#### 2.1 吞吐量

吞吐量（throughput）指CPU用于运行用户程序的时间与CPU总消耗时间的比值，即

```markdown
			运行用户代码时间
吞吐量= -------------------------
			CPU总耗费时间
```

高吞吐量的程序有更长的时间基准，不太考虑快速响应。



#### 2.2 暂停时间

暂停时间（pause time）指一个时间段内应用程序线程暂停，让GC线程执行的状态。









### 参考：

[详解CMS垃圾回收机制](https://www.cnblogs.com/Leo_wl/p/5393300.html)





