# G1收集器（Garbage-First GC）

# 一、基本介绍

## 1、Garbage-First GC

**标记整理算法**

不会产生空间碎片，可以**精确地控制停顿**

G1使用了分区和分代算法来划分堆内存空间，此时堆内存不止拥有固定的一个Eden区、两个Survivor区、一个Old区，而是变成可多个变化的Eden区、Survivor区和Old区，以及多个Humongous区。

当执行垃圾回收时，虚拟机可有计划的避免在整个堆内存上进行垃圾回收。G1可以根据各个region的垃圾堆积的价值大小，即回收所获得的空间大小以及回收所需时间的经验值，在后台维护一个相应的**优先列表**。在具体执行垃圾回收时，**优先回收价值最大的region**，即所谓的**垃圾优先（Garbage First）。**

## 2、特点

- **并行性和并发性**
- **分代GC**：与之前回收器不同，其他回收器，它们要么工作在年轻代要么工作在老年代。G1可以同时兼顾年轻代与老年代。
- **分区**
- **空间整理**：G1在回收过程中，会进行适当的对象移动，不像CMS，只是简单的标记清除，在若干次GC后CMS必须进行一次碎片整理，G1在**每次回收时都会有效的复制对象，减少空间碎片。**
- **可预见性**：由于分区的原因，G1可以只选取部分区域进行内存回收，这样缩小了回收范围，因此对于全局停顿也能得到更好的控制。

## 3、G1过程

- **年轻代GC（Young GC）**
- **老年代并发标记过程（Concurrent Marking）**
- **混合回收（Mixed GC）**
- **（如果需要）进行Full GC**





# 二、特点详解

## 1、并发和并行

**并发**是指在垃圾回收期间，Java虚拟机可以使用多个线程同时执行回收操作，这样有效的利用了设备的多核能力，提升了垃圾回收的效率。但在并发回收阶段，用户线程会触发STW。

**并行**是指G1拥有和应用程序交替执行的能力，部分工作可以和应用程序同时执行。因此，一般不会在整个回收阶段发生完全阻塞应用程序的情况。



## 2、分代收集

G1仍然遵循了分代收集理论，它将堆内存划分为很多物理上不连续的region，使用不同的region来表示Eden区、Survivor区、Old区。但此时Eden区、Survivor区和Old区的数量不再和之前使用分代收集的并发回收器一致，它们的**数量不再是固定的，同时不要求内存空间都是连续的。**

由于它将堆内存空间划分为多个新生代和老年代，同时兼顾了两代空间的垃圾回收。因此，**G1不再像之前的回收器只能单独执行某一代的回收操作，而是可以同时工作在新生代和老年代**。



## 3、分区

<img src="https://gitee.com/BlacksJack/picture-bed/raw/master/img/20200910165312.png" alt="image-20200804161636992" style="zoom:67%;" />

它将堆内存划分为2048个物理上不连续的独立的region，使用不同的region来表示Eden区、Survivor区、Old区。不同的region的大小可根据对空间的实际大小确定，通常空间在1M~32M，且为**2的次幂**。一旦确定了每个region的大小，它们在JVM的整个生命周期中就不再变化，而且每个region在具体的某次分配中只能但当一个角色。

不同的region不仅要求在物理存储上不必连续，而且它们的分配也是动态的，某个region具体作为哪一种区间是随着垃圾回收动作不断变化的，这样动态分的特点实现了逻辑上的连续。

另外还增加了一个**Humongous**区，它用来**存放创建的短期使用的大对象**。当需保存的对象大小超过了0.5个region时，JVM会将其直接放到Humongous区中。如果一个Humongous区存放不下，则会找连续的Humongous区。如果连续的Humongous区不存在，则会出发Full GC。



## 4、 空间整合

G1将内存划分为多个region，内存回收便以**region**为基础单位进行。**region之间使用的是复制算法，但整体上实际可看做是标记-整理算法，因此，回收操作可以避免内存碎片的产生。**这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发Full GC。尤其是在Java对空间非常大时，G1相对于其他的垃圾回收器优势更加明显。



## 5、可预测的停顿时间

G1除了追求低停顿时间外，还可建立**可预测的停顿时间模型**，它允许程序通过参数指定在一个长度为M毫秒的时间片段内内执行回收操作，这样就**要求收集器消耗在垃圾回收上的时间不得超过N毫秒**。

由于G1将堆内存划分为了多个region，使得回收器在执行垃圾回收操作的时间，不仅可以只针对于部分区域进行回收外，还可以根据**维护的优先列表**优先回收价值较高的区域。因此，这样的操作方式可以预测停顿时间的范围，同时保证了G1在有限的时间内获取尽可能高的收集效率。



# 三、G1过程详解

## 1、年轻代GC

应用程序分配内存时，当新生代的Eden区用尽时就开始执行Young GC。它是一个**并行的独占式收集过程**，此时G1回收器会暂停所有的用户线程，即**STW**，启动多线程执行垃圾回收操作。然后从新生代区间移动存活对象到Survivor区间或者老年代区间，可能两个区间都有涉及，取决于对象的年龄计数值。

具体的执行过程可分为五个阶段：

- 扫描根：
- 更新Remember Set
- 处理Remember Set
- 复制对象
- 处理引用

> 细节部分看了可能也模模糊糊，看完了可能也就忘了。故详细的执行过程可自行查阅相关的资料，或是浏览[**宋红康老师 - JVM教程 - G1回收器回收过程**](https://www.bilibili.com/video/BV1PJ411n7xZ?p=191)。



## 2、并发标记

当堆内存使用达到一定值（默认45%）时，开始执行**老年代的并发标记**操作。从GC Roots开始对堆中的对象进行可达性分析，递归扫描整个堆中的对象图，找出要回收的对象，标记操作与用户线程并发执行。



## 3、混合回收（Mixed GC）

当越来越多的对象晋升到老年代，为了避免堆内存被耗尽，JVM会执行混合回收（Mixed GC）操作。Mixed GG除了**回收整个新生代region外，还会回收一部分的老年代region**。对于每一个回收期来说，G1从老年代区间移动存活对象到空闲区间，这些空闲区间也就成为了整个老年代的一部分。此时老年代的回收操作一次只会回收一小部分的region，同时老年代region是和新生代一起被回收的。

如果某个区域中的所有对象都是垃圾，则会在并发标记阶段回收。如果部分对象为垃圾，则会将老年代分为8次进行回收。此时混合回收的回收集（Collection Set）包括**八分之一的老年代内存分段、Eden区内存段和Survivor内存段**。由于老年代中的内存分段默认为8次回收，因此G1会优先回收垃圾多的内存分段。

但混合回收**不一定就是要分8次回收**，以及对于区域中对象不完全是垃圾的分段也不一定会进行回收，JVM提供了相应的参数来进行设置，后续会提到相关的参数。



## 4、如果需要则进行Full GC

当某些参数设置的不合理时，G1回收的速度赶不上对象分配的速度，就会导致没有足够的空间来分配对象。此时，G1就不得不触发Full GC，暂停应用程序的执行，使用单线程的内存回收算法进行垃圾回收。当执行Full GC时，应用的程序停顿时间会很长，所以应使用合理的内存设置来尽量避免Full GC的出现。



## 相关参数

- `-XX：+UseG1GC`：手动指定使用G1回收器
- `-XX:G1HeapRegionSize`：设置每个region的大小，取值为2的次幂，范围是1M~32M
- `-XX:MaxGCPauseMillis`：设置期望达到的最大停顿时间指标，默认为200ms。该值并不是越小越好，设置的太小会影响吞吐量
- `-XX:ParallelGCThread`：设置STW工作线程数的值，最多设置为8
- `-XX:ConcGCThreads`：设置并发标记的线程数，取值一般为上一个参数的1/4左右
- `-XX:InitiatingHeapOccupancyPercent`：设置触发并发GC周期的堆占用率阈值，超过则触发GC，默认为45





## 参考文章

[Java虚拟机 -- 垃圾回收器（中篇）](https://blog.csdn.net/Forlogen/article/details/106975432)

[Java GC G1 详解](https://blog.csdn.net/jiankunking/article/details/85626279)

https://blog.csdn.net/youyou1543724847/article/details/52728244<br>


