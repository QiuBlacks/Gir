

# 堆(heap)

# 一、基本介绍
## 1、特点
==线程共享，进程私有==；

此区域是GC垃圾回收机制的主要操作区域。

存放**几乎所有**的对象实例以及数组的区域；可以认为Java中所有通过new创建的对象的内存都在此分配；**一个对象并没有逃逸出方法的话，则有可能会被优化成栈上分配。**



## 2、组成结构

### JDK8：

- 堆=新生代+老年代		
- 新生代 = Eden + S0 + S1	

![image-20200520103512653](https://gitee.com/BlacksJack/picture-bed/raw/master/img/20200910165414.png)

### JDK8之前：

JVM内存划分为堆内存和非堆内存（永久代）

Permanent Generation：永久代、持久代

<img src="https://gitee.com/BlacksJack/picture-bed/raw/master/img/20200910165415.png" alt="image-20200610154150591" style="zoom:80%;" />



## 3、默认参数

Survivor区中的对象被复制次数为15（超过这个数就会进行GC)：不同垃圾收集器不同年龄

```java
		堆=新生代+老年代	 =1：2
新生代 = Eden + S0 + S1	=8：1：1
```



## 4、异常

堆所在的物理内存区间可以是不连续的，只要逻辑连续就可以。实现时既可以是固定大小，也可以是可扩展的。如果堆无法扩展时，就会抛出OutOfMemoryError。

**OOM（“Out of Memory”）异常一般主要有如下2种原因：**

**1)年老代溢出，表现为：java.lang.OutOfMemoryError:Javaheapspace**

这是最常见的情况，产生的原因可能是：设置的内存参数Xmx过小或程序的内存泄露及使用不当问题。

例如==循环上万次的字符串处理、创建上千万个对象、在一段代码内申请上百M甚至上G的内存。==

还有的时候虽然不会报内存溢出，却会使系统不间断的垃圾回收，也无法处理其它请求。这种情况下除了检查程序、打印堆内存等方法排查，还可以借助一些内存分析工具，比如MAT就很不错。



**2)持久代溢出，表现为：java.lang.OutOfMemoryError:PermGenspace**

通常由于持久代设置过小，==动态加载了大量Java类==而导致溢出，解决办法唯有将参数 -XX:MaxPermSize 调大（一般256m能满足绝大多数应用程序需求）。将部分Java类放到容器共享区（例如Tomcat share lib）去加载的办法也是一个思路，但前提是容器里部署了多个应用，且这些应用有大量的共享类库。



# 二、GC详解

## 1、垃圾回收流程（GC）
对新生代的对象的收集称为==minor GC==；对旧生代的对象的收集称为==Full GC==；

新生代中的对象“朝生夕死”，每次GC时都会有大量对象死去，少量存活，使用复制算法。新生代又分为Eden区和Survivor区（Survivor from、Survivor to），大小比例默认为==8:1:1==。
		老年代中的对象因为对象存活率高、没有额外空间进行分配担保，就使用标记-清除或标记-整理算法。
		新产生的对象优先进去Eden区，当Eden区满了之后再使用Survivor from，当Survivor from 也满了之后就进行Minor GC（新生代GC），将Eden和Survivor from中存活的对象copy进入Survivor to，然后清空Eden和Survivor from，这个时候原来的Survivor from成了新的Survivor to，原来的Survivor to成了新的Survivor from。复制的时候，如果Survivor to 无法容纳全部存活的对象，则根据老年代的分配担保（类似于银行的贷款担保）将对象copy进去老年代，如果老年代也无法容纳，则进行Full GC（老年代GC）

**大对象直接进入老年代**：JVM中有个参数配置-XX:PretenureSizeThreshold，令大于这个设置值的对象直接进入老年代，目的是为了避免在Eden和Survivor区之间发生大量的内存复制。

**长期存活的对象进入老年代**：JVM给每个对象定义一个对象年龄计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳，将被移入Survivor并且年龄设定为1。每熬过一次Minor GC，年龄就加1，当他的年龄到一定程度（默认==为15==岁，可以通过XX:MaxTenuringThreshold来设定），就会移入老年代。但是JVM并不是永远要求年龄必须达到最大年龄才会晋升老年代，如果Survivor 空间中相同年龄（如年龄为x）所有对象大小的总和大于Survivor的一半，年龄大于等于x的所有对象直接进入老年代，无需等到最大年龄要求







## 3、GC

### 3.1 分类

#### 1）部分收集(Partial GC)：不是完整收集整个java堆的垃圾收集 

  **①：新生代收集（Minor GC/Young GC）:只是新生代的垃圾收集** 

  **②：老年代收集（Major GC/Old GC）:只是老年代的垃圾收集** 

  目前只有CMS垃圾收集器才有单独的老年代的收集 

  **③：混合收集：收集整个新生代和部分老年代的垃圾收集** 

 目前只有G1垃圾收集器具备混合收集（因为它是基于region的垃圾收集） 



#### 2）整堆收集（Full GC）：完整收集java堆及方法区的垃圾收集



### 3.2 触发

- **Mior GC** 
  - 触发条件：当伊甸园区满了，就会触发Minor GC,回收整个年轻代的垃圾（s0和s1区满不会触发Minor GC） 
  - 触发后果：当进行Minor GC时，会造成STW（Stop The World）,会停止运行用户其他线程。 

- **Major GC** 
  - 触发条件：当老年代的内存空间不足时，会优先触发Minor GC,如果之后还不足，则会触发Major GC 
  - 触发后果：Major GC比Minor GC的速度要慢十倍以上，造成更长时间的STW。 

- **Full GC** 
  - 触发条件： 
    - 调用System.gc时，系统建议执行Full GC，但是不必然执行
    - 老年代空间不足
    - 方法区(1.8之后改为元空间)空间不足
    - 创建大对象，比如数组，通过Minor GC后，进入老年代的平均大小大于老年代的可用内存
    - 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小







# 三、参数调整

## 1、堆内存

**-Xms：设置堆空间（新生代+老年代）的起始内存大小**

**-Xmx：设置堆空间（新生代+老年代）的最大内存大小**

补充：-X是虚拟机的运行参数；ms:memory size的意思

- 默认的堆空间的起始内存大小：电脑运行内存的大小/64；
- 默认的堆空间的最大内存大小：电脑运行内存的大小/4；





https://blog.csdn.net/sivyer123/article/details/17139443



# 四、重要知识点

## 1、为什么要分为Eden和Survivor?为什么要设置两个Survivor区？

1）如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC.老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多,增加了内存使用率

2）Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。

3）设置两个Survivor区最大的好处就是==解决了碎片化==，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1<br>

（这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生）



## 2、为什么分为新生代和老年代

  不同对象的生命周期是不同的，70%-90%的对象的生命周期是短暂的，在新生代主要存放生命周期短暂的对象，在老年代存放新生代中经过多次垃圾回收之后依然没有没有被回收的对象，这样做主要是为了优化GC的性能，如果不分新生代和老年代，而是将对象都放在一起，则每次GC的时候都要遍**历整个堆空间**，会造成STW的时间较长，影响用户性能体验。



## 3、Java中的对象都是在堆中分配吗？

### 3.1 问题引出

我们知道我们通过GC回收垃圾对象，如果存在大量**临时对象**，就会给GC带来压力，这时就用到我们的逃逸分析了。

### 3.2 逃逸分析

虚拟机能够通过分析来**判断对象的引用范围是否在方法内部**，从而决定是否将对象份分配到堆上。

如果一个对象在方法中被定义后，对象**只在方法内部**进行使用，则认为**没有发生逃逸**，我们就直接将对象放进**栈中分配**，分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。

### 3.3 好处

栈空间直接作为临时对象的存储介质。从而减少了临时对象在堆内的分配数量

