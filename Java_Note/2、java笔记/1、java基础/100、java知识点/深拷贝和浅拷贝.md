# 深拷贝和浅拷贝
---

# 一、浅拷贝
## 1、定义
&emsp;&emsp;创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。因此，原始对象及其副本引用同一个对象。<br>
&emsp;&emsp;所以，当你改变其中一个引用的值，另一个也会变化


# 二、深拷贝
## 1、定义
&emsp;&emsp;　深拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该新对象，无论该字段是值类型的还是引用类型，都复制独立的一份。
当你修改其中一个对象的任何内容时，都不会影响另一个对象的内容

## 2、图解
![image](WEBRESOURCEfcec9b729d16e998eebc2ea483e10069)
## 3、实现深拷贝
- 1）让==每个引用类型==属性内部都重写clone() 方法<br>

&emsp;&emsp;既然引用类型不能实现深拷贝，那么我们将每个引用类型都拆分为基本类型，分别进行浅拷贝。 

&emsp;&emsp;弊端：如果引用类也存在一个引用类型，那么我们也要重写其clone 方法，这样下去，有多少个引用类型，我们就要重写多少次，如果存在很多引用类型，那么代码量显然会很大

- 2）利用序列化

&emsp;&emsp;序列化是将对象写到流中便于传输，而反序列化则是把对象从流中读取出来。这里写到流中的对象则是原始对象的一个拷贝，因为原始对象还存在 JVM 中，所以我们可以利用对象的序列化产生克隆对象，然后通过反序列化获取这个对象。

&emsp;&emsp;　　注意每个需要序列化的类都要实现 Serializable 接口，如果有某个属性不需要序列化，可以将其声明为 transient，即将其排除在克隆属性之外。


# 三、如何实现对象克隆？

## 有两种方式：

1). 实现Cloneable接口并重写Object类中的clone()方法；

2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆

# 四、深拷贝和浅拷贝区别是什么？

&emsp;&emsp;浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()）<br>
&emsp;&emsp;深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）

参考：https://www.cnblogs.com/ysocean/p/8482979.html<br>
&emsp;&emsp;https://blog.csdn.net/baiye_xing/article/details/71788741