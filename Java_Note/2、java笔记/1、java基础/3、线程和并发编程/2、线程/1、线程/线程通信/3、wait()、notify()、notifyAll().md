[TOC]



## wait()、notify()、notifyAll()

可以让线程放弃占有，从而破坏死锁

### 1、方法介绍

#### 1）wait（） ：等待

将正在执行的线程释放其执行资格 和 执行权，并存储到线程池中。==线程不会自动苏醒，需要别的线程唤醒。==

当线程执行wait()方法时候，会==释放当前的锁==，然后让出CPU，进入等待状态。

)需要被try catch包围，以便发生异常中断也可以使wait等待的线程唤醒。

#### 2）notify（）：唤醒

​	唤醒线程池中被wait（）的线程，一次唤醒一个，而且是任意的。

#### 3）notifyAll（）： 唤醒全部

可以将线程池中的所有wait() 线程都唤醒。

所谓唤醒的意思就是让 线程池中的线程具备执行资格。必须注意的是，这些方法都是在 同步中才有效。同时这些方法在使用时必须标明所属锁，这样才可以明确出这些方法操作的到底是哪个锁上的线程。 等待中的线程必须由notify()方法显式地唤醒，否则它会永远地等待下去。

notify/notifyAll() 的执行只是唤醒沉睡的线程，而不会立即释放锁，锁的释放要看代码块的具体执行情况。所以在编程中，尽量在使用了notify/notifyAll() 后立即退出临界区，以唤醒其他线程让其获得锁

### 2、notify 和 notifyAll的区别

notify方法只唤醒一个等待（对象的）线程并使该线程开始执行。所以如果有多个线程等待一个对象，这个方法只会唤醒其中一个线程，选择哪个线程取决于==操作系统对多线程管理的实现==。

notifyAll 会唤醒所有等待(对象的)线程，至于==哪一个线程将会第一个处理取决于操作系统的实现==。如果当前情况下有多个线程需要被唤醒，推荐使用notifyAll 方法。比如在生产者-消费者里面的使用，每次都需要唤醒所有的消费者或是生产者，以判断程序是否可以继续往下执行



### 3、在多线程中要测试某个条件的变化，使用if 还是while？

　　要注意，notify唤醒沉睡的线程后，线程会接着上次的执行继续往下执行。所以在进行条件判断时候，可以先把 wait 语句忽略不计来进行考虑；显然，要确保程序一定要执行，并且要保证程序直到满足一定的条件再执行，要使用while进行等待，直到满足条件才继续往下执行。



### 4、使用注意：

这三个方法均只能使用在==同步代码块或者同步方法==中。

使用时必须标识它们所操作的线程持有的锁，因为等待和唤醒必须是==同一锁==下的线程；

wait()、notify/notifyAll() 方法是Object的本地final方法，无法被重写。



### 5、sleep和wait的异同：

相同点：一旦执行方法以后，都会使得当前的进程进入阻塞状态，都可以暂停线程的执行

不同点：

- 两个方法声明的位置不同，Thread类中声明sleep，Object类中声明wait。
- 调用的要求不同，sleep可以在任何需要的场景下调用，wait必须使用在同步代码块或者同步方法中
- 关于==是否释放锁==（同步监视器），如果两个方法都使用在同步代码块或同步方法中，sleep不会释放，wait会释放
- wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。