[TOC]

# 一、线程间通信

## 1、为什么要线程通信？

线程是操作系统中独立的个体，但这些个体如果不经过特殊的处理就不能成为一个整体。多个线程并发执行时,在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行,那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。
  狭义上来说：线程通信的目标是使线程间能够互相发送信号(通知),另一方面，线程通信使线程能够等待其他线程的信号(通知),也称为线程间的等待/通知机制，或者生产消费模式！

广义上说：能够协调线程调度运行的方法都属于线程通信的应用，不应是一个线程主动通知另外一个线程，这个通知还可能是一个公共信号。



## 2、线程通信方式

### 2.1   锁机制：包括互斥锁、条件变量、读写锁

互斥锁提供了以排他方式防止数据结构被并发修改的方法。 
		读写锁允许多个线程同时读共享数据，而对写操作是互斥的。 
		条件变量可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用。



wait/notify 等待

使用 ReentrantLock 结合 Condition

共享变量

管道

Volatile 内存共享

while轮询的方式



### 2.2    信号量机制(Semaphore)

包括无名线程信号量和命名线程信号量。



### 2.3    信号机制(Signal)

类似进程间的信号处理。

线程间的通信目的主要是用于线程同步，所以线程没有像进程通信中的用于数据交换的通信机制。



## 3、线程间同步方式

各个线程可以访问进程中的公共变量，资源，所以使用多线程的过程中需要注意的问题是如何防止两个或两个以上的线程同时访问同一个数据，以免破坏数据的完整性。数据之间的相互制约包括

- 直接制约关系，即一个线程的处理结果，为另一个线程的输入，因此线程之间直接制约着，这种关系可以称之为同步关系

- 间接制约关系，即两个线程需要访问同一资源，该资源在同一时刻只能被一个线程访问，这种关系称之为线程间对资源的互斥访问，某种意义上说互斥是一种制约关系更小的同步

  

线程间的同步方式有四种

### 3.1  互斥量(Mutex)

采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有**一个**，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 synchronized 关键词和各种 Lock 都是这种机制。

### 3.2、信号量(Semphares) 

它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量

信号量（Semaphore）是一个整型变量，可以对其执行自增和自减操作，自减操作通常也叫做P操作，自增操作也称为V操作。这两个操作需要被设计成原语，是不可分割，通常的做法是在执行这些操作的时候屏蔽中断。进程使用这两个操作进行同步。

- 对于P操作，如果执行操作后信号量小于 0，那么执行该操作的进程就会阻塞，否则继续执行； 
- 对于V操作，如果操作之后的信号量小于等于0，那么就会从阻塞队列唤醒一个进程。

### 3.3 、事件(Event) 

Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操

### 3.4、临界区

临界区是一段代码，在临界区内进程将访问临界资源。任何时候最多只有一个进程可以进入临界区，也就是说，临界区具有排他性。所以，为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。

临界区对应着一个CcriticalSection对象，当线程需要访问保护数据时，调用EnterCriticalSection函数；当对保护数据的操作完成之后，调用LeaveCriticalSection函数释放对临界区对象的拥有权，以使另一个线程可以夺取临界区对象并访问受保护的数据。







## 参考文献：

[java多线程之线程间的通信方式](https://www.cnblogs.com/hapjin/p/5492619.html)

[JAVA线程与线程、进程与进程间通信](https://blog.csdn.net/ls5718/article/details/51878770)





# 二、进程间通信

进程间通信又称IPC(Inter-Process Communication),指多个进程之间相互通信，交换信息的方法。根据进程通信时信息量大小的不同,可以将进程通信划分为两大类型:

## 1、低级通信

​		控制信息的通信(主要用于进程之间的同步,互斥,终止和挂起等等控制信息的传递)

## 2、高级通信

​	大批数据信息的通信(主要用于进程间数据块数据的交换和共享,常见的高级通信有管道,消息队列,共享内存等).

### 2.1 管道( pipe )

#### 2.1.1 匿名管道

管道是一种半双工的通信方式，数据只能**单向流动**，而且只能在**具有亲缘关系的进程间**使用。进程的亲缘关系通常是指父子进程关系。

```
netstat -tulnp | grep 8080
```

”|“是**管道**的意思，它的作用就是把前一条命令的输出作为后一条命令的输入。

这种通信方式是单向的，只能把第一个命令的输出作为第二个命令的输入，如果进程之间想要互相通信的话，那么需要创建两个管道。

#### 2.1.2 命名管道

有名管道也是半双工的通信方式，但是它**允许无亲缘关系**进程间的通信。

创建一个命名管道

```
mkfifo  test
```

接下来我们用一个进程向这个管道里面写数据，然后有另外一个进程把里面的数据读出来。

```bash
echo "this is a pipe" > test   #写数据
```

这个时候管道的内容没有被读出的话，那么这个命令就会一直停在这里，只有当另外一个进程把 test 里面的内容读出来的时候这条命令才会结束。接下来我们用另外一个进程来读取

```
cat < test  // 读数据
```

从上面的例子可以看出，管道的通知机制类似于**缓存**，就像一个进程把数据放在某个缓存区域，然后等着另外一个进程去拿，并且是管道是**单向传输的。**

这种通信方式有什么缺点呢？显然，这种通信方式**效率低下**，你看，**a 进程给 b 进程传输数据，只能等待 b 进程取了数据之后 a 进程才能返回。**

所以管道不适合频繁通信的进程。当然，他也有它的优点，例如比较简单，能够保证我们的数据已经真的被其他进程拿走了。我们平时用 Linux 的时候，也算是经常用。



### 2.2 消息队列( message queue ) 

#### 2.2.1  问题引出

那我们能不能把进程的数据放在某个内存之后就**马上让进程返回**呢？无需等待其他进程来取就返回呢？

#### 2.2.2  解决方法

消息队列是由消息的链表，存放在内核中并由**消息队列**标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

例如 a 进程要给 b 进程发送消息，只需要把消息放在对应的消息队列里就行了，b 进程需要的时候再去对应的消息队列里取出来。同理，b 进程要个 a 进程发送消息也是一样。这种通信方式也类似于**缓存**吧。

#### 2.2.3  缺点

如果 a 进程发送的数据占的内存比较大，并且两个进程之间的通信特别频繁的话，消息队列模型就不大适合了。因为 a 发送的数据很大的话，意味**发送消息（拷贝）**这个过程需要花很多时间来读内存。



### 2.3 共享内存( shared memory )

#### 2.3.1 问题引出

**共享内存**这个通信方式就可以很好着解决**拷贝**所消耗的时间了。

这个可能有人会问了，每个进程不是有自己的独立内存吗？两个进程怎么就可以共享一块内存了？

我们都知道，系统加载一个进程的时候，分配给进程的内存并不是**实际物理内存**，而是**虚拟内存空间**。那么我们可以让两个进程各自拿出一块虚拟地址空间来，然后映射到相同的物理内存中，这样，两个进程虽然有着独立的虚拟内存空间，但有一部分却是映射到相同的物理内存，这就完成了**内存共享**机制了。

#### 2.3.2  定义

共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。



### 2.4 信号量( semophore ) 

#### 2.4.1 问题引出

共享内存最大的问题是什么？没错，就是多进程竞争内存的问题，就像类似于我们平时说的**线程安全**问题。如何解决这个问题？这个时候我们的**信号量**就上场了。

信号量的本质就是一个**计数器**，用来实现进程之间的互斥与同步。

例如信号量的初始值是 1，然后 a 进程来访问**内存1**的时候，我们就把信号量的值设为 0，然后进程b 也要来访问**内存1**的时候，看到信号量的值为 0 就知道已经有进程在访问**内存1**了，这个时候进程 b 就会访问不了**内存1**。所以说，信号量也是进程之间的一种通信方式。

#### 2.4.2  概念

信号量是一个计数器，可以用来控制多个进程对共享资源的访问。不是用于交换大批数据,而用于多线程之间的同步.常作为一种锁机制,防止某进程在访问资源时其它进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。



### 2.5  套接字( socket )

套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。

此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

