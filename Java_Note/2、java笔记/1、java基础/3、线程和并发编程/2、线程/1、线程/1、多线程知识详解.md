

[TOC]



# 多线程知识详解

--------------------------------------------------------------------------------

## 一、基本定义

### 1、程序

​	是为完成特定任务，用某种语言编写的**一组指令的集合**，即指一段静态的代码，静态对象。

### 2、进程（同步）

​	是程序的一次执行过程，或是正在运行的一个程序，是一个动态的过程，是**资源分配的最小单位**

### 3、线程（同步）

​	线程是比进程更小的执行单位，一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程**共享==进程==的堆和方法区资源**，但每个线程有自己的**程序计数器、虚拟机栈和本地方法栈**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。

一个程序至少一个进程，一个进程至少一个线程。

### 4、协程（异步）

#### 4.1 基本定义

​	是一种用户态的轻量级线程。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。

​	因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。

#### 4.2  协程的好处：

- 无需线程上下文切换的开销
- 无需原子操作锁定及同步的开销
- 方便切换控制流，简化编程模型

高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。

#### 4.3  缺点：

- 无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。
- 进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序



### 5、并行：

​		多个CPU同时执行多个任务，比如:多个人同时做不同的事

### 6、并发：

​		一个CPU（采用时间片）同时执行多个任务但在任意一个时间点上，只有一个程序在CPU上运行。

​					比如秒杀平台，多个人做同件事



## 二、进程线程的区别
1、**独立的地址空间（最大不同）**：同一进程的线程**共享本进程的地址空间**，而进程之间则是**独立**的地址空间。

2、资源拥有：同一进程内的线程共享本进程的资源，但是进程之间的资源是独立的。

3、一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。

4、进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程。

5、执行过程：每个独立的进程程有一个程序运行的入口、顺序执行序列和程序入口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

6、线程是处理器调度的基本单位，但是进程不是。

7、两者均可并发执行。





## 三、线程的生命周期

![image-20200617111713171](E:/black user/Java/有道云截图/image-20200617111713171.png)

### 1、新建状态（New）

• 用new关键字建立一个线程对象后，该线程对象就处于新生状态。

• 处于新生状态的线程有自己的内存空间，通过调用start进入就绪状态



### 2、就绪状态（Runnable）

当调用线程对象的start()方法，线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU**调度执行**，并不是说执行了t.start()此线程立即就会执行；



### 3、运行状态（Running）

当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。

注：**就绪状态是进入到运行状态的唯一入口**，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中；



### 4、阻塞状态（Blocked）

处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，**在阻塞状态的线程不能进入就绪队列**，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种：

1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态；

2.同步阻塞 -- 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；

3.其他阻塞 -- 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。



### 5、死亡状态（Dead）

线程执行完了或者因异常退出了run()方法，该线程结束生命周期。线程死亡的原因有三个。一个是正常运行的线程完成了它的全部工作；另一个是线 程被强制性地终止，如通过执行stop方法来终止一个线程[不推荐使用】，三是线程抛出未捕获的异常





## 四、线程安全的实现
### 1、互斥同步
synchronized 和 ReentrantLock。

### 2、 非阻塞同步
- CAS
- 原子变量AtomicXXXX

### 3、无同步方案 
栈封闭，Thread Local，可重入代码



## 五、为什么使用多线程

先从总体上来说：

- **从计算机底层来说：** 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。
- **从当代互联网发展趋势来说：** 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。

再深入到计算机底层来探讨：

- **单核时代：** 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。
- **多核时代:** 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。



## 六、多线程带来的问题

并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、上下文切换、死锁还有受限于硬件和软件的资源闲置问题。







## 参考文献：

[Java多线程学习(三)---线程的生命周期](https://www.cnblogs.com/sunddenly/p/4106562.html)





