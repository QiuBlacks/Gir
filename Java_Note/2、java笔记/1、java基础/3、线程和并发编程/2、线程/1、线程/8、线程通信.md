[TOC]

　

参考：https://blog.csdn.net/weixin_43767015/article/details/104938047



# 线程通信

## 一、基本介绍

### 1、为什么要线程通信？

 线程是操作系统中独立的个体，但这些个体如果不经过特殊的处理就不能成为一个整体。多个线程并发执行时,在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行,那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。
  狭义上来说：线程通信的目标是使线程间能够互相发送信号(通知),另一方面，线程通信使线程能够等待其他线程的信号(通知),也称为线程间的等待/通知机制，或者生产消费模式！

广义上说：能够协调线程调度运行的方法都属于线程通信的应用，不应是一个线程主动通知另外一个线程，这个通知还可能是一个公共信号。






## 二、通信方式



### 1、wait/notify机制

### 2、synchronized 线程通信（JDK1.5前）

### 3、lock+Condition控制线程通信（JDK1.5后）

   （1）将同步synchronized替换为显式的**Lock**操作；

​    （2）将Object类中的wait(), notify(),notifyAll()替换成了**Condition**对象，该对象可以通过Lock锁对象获取;

​    （3）一个Lock对象上可以绑定多个Condition对象，这样实现了本方线程只唤醒对方线程，而jdk1.5之前，一个同步只能有一个锁，不同的同步只能用锁来区分，且锁嵌套时容易死锁。

```java
class Resource{  
        private String name;  
        private int count=1;  
        private boolean flag=false;  
        private Lock lock = new ReentrantLock();/*Lock是一个接口，ReentrantLock是该接口的一个直接子类。*/  
        private Condition condition_pro=lock.newCondition(); /*创建代表生产者方面的Condition对象*/  
        private Condition condition_con=lock.newCondition(); /*使用同一个锁，创建代表消费者方面的Condition对象*/  
          
        public void set(String name){  
            lock.lock();//锁住此语句与lock.unlock()之间的代码  
            try{  
                while(flag)  
                    condition_pro.await(); //生产者线程在conndition_pro对象上等待  
                this.name=name+"---"+count++;  
                System.out.println(Thread.currentThread().getName()+"...生产者..."+this.name);  
                flag=true;  
                 condition_con.signalAll();  
            }  
            finally{  
                lock.unlock(); //unlock()要放在finally块中。  
            }  
        }  
        public void out(){  
            lock.lock(); //锁住此语句与lock.unlock()之间的代码  
            try{  
                while(!flag)  
                    condition_con.await(); //消费者线程在conndition_con对象上等待  
            System.out.println(Thread.currentThread().getName()+"...消费者..."+this.name);  
            flag=false;  
            condition_pro.signqlAll(); /*唤醒所有在condition_pro对象下等待的线程，也就是唤醒所有生产者线程*/  
            }  
            finally{  
                lock.unlock();  
            }  
        }  
    }
```



### 4、while语句轮询





## 三、等待与唤醒(wait()、notify()、notifyAll())

可以让线程放弃占有，从而破坏死锁



### 1、方法介绍

**-** **wait（） :等待，将正在执行的线程释放其执行资格 和 执行权，并存储到线程池中。==线程不会自动苏醒，需要别的线程唤醒。==**

**-** **notify（）：唤醒，唤醒线程池中被wait（）的线程，一次唤醒一个，而且是任意的。**

**-**  **notifyAll（）： 唤醒全部：可以将线程池中的所有wait() 线程都唤醒。**

所谓唤醒的意思就是让 线程池中的线程具备执行资格。必须注意的是，这些方法都是在 同步中才有效。

同时这些方法在使用时必须标明所属锁，这样才可以明确出这些方法操作的到底是哪个锁上的线程。 

等待中的线程必须由notify()方法显式地唤醒，否则它会永远地等待下去。



### **2、使用注意：**

**这三个方法均只能使用在同步代码块或者同步方法中。**

**使用时必须标识它们所操作的线程持有的锁，因为等待和唤醒必须是同一锁下的线程；**



### **3、sleep和wait的异同：**

**相同点：**一旦执行方法以后，都会使得当前的进程进入阻塞状态，都可以暂停线程的执行

**不同点：**

- 两个方法声明的位置不同，Thread类中声明sleep，Object类中声明wait。
- 调用的要求不同，sleep可以在任何需要的场景下调用，wait必须使用在同步代码块或者同步方法中
- 关于==是否释放锁==（同步监视器），如果两个方法都使用在同步代码块或同步方法中，sleep不会释放，wait会释放
- wait() 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify() 或者 notifyAll() 方法。sleep() 方法执行完成后，线程会自动苏醒。或者可以使用 wait(long timeout)超时后线程会自动苏醒。





## **四、经典例题：生产者/消费者问题：**

生产者（Priductor）将产品交给店员（Clerk），而消费者（Customer）从店员处取走产品，店员一次只能持有固定数量的产品（比如20个），如果生产者视图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产：如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品。

这里可能出现两个问题：

生产者比消费者快的时候，消费者会漏掉一些数据没有收到。

消费者比生产者快时，消费者会去相同的数据。

**2、代码实现**

**定义缓冲区（店员）**

```java
/**
 * 线程通信的应用：生产者/消费者问题
 *
 * 1.是否是多线程问题？是的，有生产者线程和消费者线程（多线程的创建，四种方式）
 * 2.多线程问题是否存在共享数据？ 存在共享数据----产品（同步方法，同步代码块，lock锁）
 * 3.多线程是否存在线程安全问题？ 存在----都对共享数据产品进行了操作。（三种方法）
 * 4.是否存在线程间的通信，是，如果生产多了到20时，需要通知停止生产（wait）。（线程之间的通信问题，需要wait，notify等）
 *
 * */

	class Clerk{
	
	    private int productCount = 0;
	
	
	    //生产产品
	    public synchronized void produceProduct() {
	
	        if(productCount<20) {
	            productCount++;
	
	            System.out.println(Thread.currentThread().getName()+":开始生产第"+productCount+"个产品");
	            notify();
	        }else{
	            //当有20个时，等待wait
	            try {
	                wait();
	            } catch (InterruptedException e) {
	                e.printStackTrace();
	            }
	        }
	    }
	
	    //消费产品
	    public synchronized void consumeProduct() {
	        if (productCount>0){
	            System.out.println(Thread.currentThread().getName()+":开始消费第"+productCount+"个产品");
	            productCount--;
	            notify();
	        }else{
	            //当0个时等待
	            try {
	                wait();
	            } catch (InterruptedException e) {
	                e.printStackTrace();
	            }
	        }
	    }
	}
```

**定义生产者**

```java
	class Producer extends Thread{//生产者线程
	
	    private Clerk clerk;
	
	    public Producer(Clerk clerk) {
	        this.clerk = clerk;
	    }
	
	    @Override
	    public void run() {
	
	        try {
	            sleep(10);
	        } catch (InterruptedException e) {
	            e.printStackTrace();
	        }
	        System.out.println(Thread.currentThread().getName()+";开始生产产品......");
	
	        while(true){
	            clerk.produceProduct();
	        }
	    }
	}
```

**定义消费者线程**

```java
class Consumer implements Runnable{//消费者线程
	
	    private Clerk clerk;
	
	    public Consumer(Clerk clerk) {
	        this.clerk = clerk;
	    }
	
	    @Override
	    public void run() {
	
	        System.out.println(Thread.currentThread().getName()+":开始消费产品");
	
	        while(true){
	            try {
	                Thread.sleep(1);
	            } catch (InterruptedException e) {
	                e.printStackTrace();
	            }
	
	            clerk.consumeProduct();
	        }
	
	    }
	}
```

**测试**

​	

```java
	public class ProductTest {
	
	    public static void main(String[] args){
	        Clerk clerk = new Clerk();
	
	        Producer p1 = new Producer(clerk);
	        p1.setName("生产者1");
	
	        Consumer c1 = new Consumer(clerk);
	        Thread t1 = new Thread(c1);
	        t1.setName("消费者1");
	
	        p1.start();
	        t1.start();
	
	    }
	
	}
```

