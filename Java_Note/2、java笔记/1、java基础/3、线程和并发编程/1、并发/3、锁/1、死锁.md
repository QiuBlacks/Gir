# 死锁

## 一、基本介绍

### 1、定义

多个线程同时被阻塞，它们中的一个或者全部都在等待其他某个进程的资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止

### 2、图解

如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态

<img src="https://gitee.com/BlacksJack/picture-bed/raw/master/img/20200910165539.png" alt="image-20200519155033827" style="zoom: 50%;" />





## 二、产生死锁的原因

### 1、竞争资源

1）系统中的资源可以分为两类：

- 可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；
- 另一类资源是不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。

产生死锁中的竞争资源之一指的是竞争不可剥夺资源（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）

产生死锁中的竞争资源另外一种资源指的是竞争临时资源（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁


### 2、进程间推进顺序不合适

- 若P1保持了资源R1,P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁
- 例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁



## 三、死锁的四个必要条件

根本原因：多个进程竞争资源时，进程的推进顺序出现不正确。

- 互斥条件：				一个资源每次只能被一个进程使用
- 请求与保持条件：   一个进程因请求资源而阻塞时，对已获得的资源保持不放
- 不剥夺条件:	          进程已获得的资源，在末使用完之前，不能强行剥夺
- 循环等待条件:      	若干进程之间形成一种头尾相接的循环等待资源关系





## 四、解决死锁

### 1、死锁预防：破坏四个必要条件

- **破坏互斥条件** ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。
- **破坏请求与保持条件** ：一次性申请所有的资源；只要有一个资源得不到分配，也不给这个进程分配其他的资源
- **破坏不剥夺条件** ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。
- **破坏循环等待条件** ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。



### 2、避免死锁

为了避免因为预防死锁而导致所有线程变慢，死锁避免采用了与死锁预防相反的措施。它允许三个必要条件，但通过算法**判断资源请求是否可能导致循环等待的形成并相应决策**，来避免死锁点的产生。因此，其前提是知道当前资源使用的整体情况，以及申请资源线程本身所占有的资源细节。

判断和决策中，主要使用两种避免方法。

- 线程启动拒绝：如果一个线程的请求会引发死锁，则不允许其启动。 
- 资源分配拒绝：如果一个线程增加的资源请求会导致死锁，则不允许此申请。 

整体来看，**死锁避免是从资源和线程相互间关系着手，避免形成循环等待是其主要任务。**



#### 1）加锁顺序（线程按照一定的顺序加锁）

当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。

如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。

看下面这个例子：线程3需要一些锁，那么它必须按照确定的顺序获取锁。它只有获得了从顺序上排在前面的锁之后，才能获取后面的锁。

```
Thread 1:
  lock A 
  lock B

Thread 2:
   wait for A
   lock C (when A locked)

Thread 3:
   wait for A
   wait for B
   wait for C
```

#### 2）加锁时限

线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁

```
Thread 1 locks A
Thread 2 locks B

Thread 1 attempts to lock B but is blocked
Thread 2 attempts to lock A but is blocked

Thread 1's lock attempt on B times out
Thread 1 backs up and releases A as well
Thread 1 waits randomly (e.g. 257 millis) before retrying.

Thread 2's lock attempt on A times out
Thread 2 backs up and releases B as well
Thread 2 waits randomly (e.g. 43 millis) before retrying.
```





### 3、死锁检测和恢复

死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景

每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。<br>

当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。例如，线程A请求锁7，但是锁7这个时候被线程B持有，这时线程A就可以检查一下线程B是否已经请求了线程A当前所持有的锁。如果线程B确实有这样的请求，那么就是发生了死锁（线程A拥有锁1，请求锁7；线程B拥有锁7，请求锁1）<br><img src="https://gitee.com/BlacksJack/picture-bed/raw/master/img/20200910165540.png" alt="image-20200614152343056" style="zoom:67%;" />



那么当检测出死锁时，这些线程该做些什么呢？

一个可行的做法是==释放所有锁==，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁（*编者注：原因同超时类似，不能从根本上减轻竞争*）。

一个更好的方案是给这些线程==设置优先级==，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。

目前操作系统中主要采用如下几种方法：

- 取消所有死锁相关线程，简单粗暴，但也确实是最常用的 
- 把每个死锁线程回滚到某些检查点，然后重启 
- 连续取消死锁线程直到死锁解除，顺序基于特定最小代价原则 
- 连续抢占资源直到死锁解除



### 4、鸵鸟策略

就是直接忽略死锁。就像鸵鸟遇到危险的时候，把头埋在沙子里，假装根本没发生问题。因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。

当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。









