# volatile
# 一、基本介绍
## 1、作用
1）防重排序

2）实现可见性

## 2、volatile对三大特性的实现
Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于内存模型的高速缓存）

线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存

### 1）原子性 ( 无法保证 )
**单单volatile无法保证原子性**
		例如：
		线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。

### 2）可见性

当对volatile变量进行写操作的时候，JVM会向处理器发送一条**lock前缀的指令**，然后CPU会立即这个缓存中的变量写到系统主存中

### 3)有序性

在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。

volatile关键字禁止指令重排序有两层意思：

- 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
- 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。



# 二、实现原理

Java内存模型中定义了以下八种操作来完成：lock:(锁定)，unlock(解锁)，read(读取)，load(载入)，use(试用)， assign(赋值)，store(存储)，write(写入)。

volatile 对这八种操作有着**两个特殊的限定**，正因为有这些限定才让volatile修饰的变量有可见性以及可以禁止指令重排序 ：

-  use动作之前必须要有read和load动作， 这三个动作必须是连续出现的。【表示：每次工作内存要使用volatile变量之前必须去主存中拿取最新的volatile变量】
- assign动作之后必须跟着store和write动作，这三个动作必须是连续出现的。【表示: 每次工作内存改变了volatile变量的值，就必须把该值写回到主存中】

有以上两条规则就能保证每个线程每次去拿volatile变量的时候，那个变量肯定是最新的， 其实也就相当于好多个线程用的是同一个内存，无工作内存和主存之分。而操作没有用volatile修饰的变量则不能保证每次都能获取到最新的变量值。



## 1、可见性

### 1.1 定义

是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。



### 1.2 实现方法

当对volatile变量进行写操作的时候，JVM会向处理器发送一条**lock前缀的指令**，然后CPU会立即这个缓存中的变量写到系统主存中

遵守happends-before关系





## 2、有序性

### 2.1 基本介绍

在程序运行时，为了提高执行性能，编译器和处理器会对指令进行

排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止 特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。

### 2.2 实现方法

volatile 变量的内存有序性是基于**内存屏障(Memory Barrier)**实现:
		内存屏障，又称内存栅栏，是一个 CPU 指令

编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。



JMM为volatile加内存屏障有以下4种情况：

- 在每个volatile写操作的前面插入一个StoreStore屏障，防止写volatile与后面的写操作重排序。
- 在每个volatile写操作的后面插入一个StoreLoad屏障，防止写volatile与后面的读操作重排序。
- 在每个volatile读操作的后面插入一个LoadLoad屏障，防止读volatile与后面的读操作重排序。
- 在每个volatile读操作的后面插入一个LoadStore屏障，防止读volatile与后面的写操作重排序。





# 三、应用场景
## 1、使用 volatile 必须具备的条件:
- 对变量的写操作不依赖于当前值。
- 该变量没有包含在具有其他变量的不变式中。
- 只有在状态真正独立于程序内其他内容时才能使用 volatile。



# 四、常见知识点

## 1、synchronized 和 volatile 区别

synchronized 关键字和 volatile 关键字是两个互补的存在，而不是对立的存在！

- **volatile 关键字**是线程同步的**轻量级实现**，所以**volatile 性能肯定比 synchronized 关键字要好**。但是**volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块**。
- **volatile 关键字能保证数据的可见性，但不能保证数据的原子性。synchronized 关键字两者都能保证。**
- **volatile 关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。**



## 2、volatile能否保证线程安全性

在某些特定的情况下能。

volatile能保证线程安全的情况：要使 volatile 变量提供理想的线程安全性，必须同时满足两个条件：

①对变量的写操作不依赖于当前值。②该变量没有包含在具有其他变量的不变式中。





## 参考文章

[Java并发编程：volatile关键字解析](https://www.cnblogs.com/dolphin0520/p/3920373.html)

[关键字: volatile详解](https://www.pdai.tech/md/java/thread/java-thread-x-key-volatile.html)