# volatile
# 一、基本介绍
## 1、作用
1）防重排序

2）实现可见性

## 2、volatile对三大特性的实现
Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于内存模型的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存
### 1）原子性
单单volatile无法保证原子性
		例如：
		线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。


### 3)有序性
在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。
　	volatile关键字禁止指令重排序有两层意思：

- 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
- 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。



# 二、实现原理
## 1、volatile 可见性实现
volatile 变量的内存可见性是基于内存屏障(Memory Barrier)实现:
		内存屏障，又称内存栅栏，是一个 CPU 指令	
		在程序运行时，为了提高执行性能，编译器和处理器会对指令进行

排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止 特定类型的编译器重排序和处理器重排序，插入一条内存屏障会告诉编译器和 CPU：不管什么指令都不能和这条 Memory Barrier 指令重排序。

## 2、有序性实现
volatile 的 happens-before 关系





# 三、应用场景
## 1、使用 volatile 必须具备的条件:
- 对变量的写操作不依赖于当前值。
- 该变量没有包含在具有其他变量的不变式中。
- 只有在状态真正独立于程序内其他内容时才能使用 volatile。









## 参考文章

[Java并发编程：volatile关键字解析](https://www.cnblogs.com/dolphin0520/p/3920373.html)

[关键字: volatile详解](https://www.pdai.tech/md/java/thread/java-thread-x-key-volatile.html)