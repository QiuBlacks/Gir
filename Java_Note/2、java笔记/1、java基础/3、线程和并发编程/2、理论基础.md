# 2、理论基础

---


# 一、为什么需要多线程
&emsp;&emsp;众所周知，CPU、内存、I/O 设备的速度是有极大差异的，为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都做出了贡献，主要体现为:
- CPU 增加了缓存，以均衡与内存的速度差异；									// 导致 可见性问题
- 操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；// 导致 原子性问题
- 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。					// 导致 有序性问题


# 二、并发三要素（并发问题的根源）

## 1、原子性: 分时复用引起
&emsp;&emsp;即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

## 2、可见性: CPU缓存引起
&emsp;&emsp;一个线程对共享变量的修改，另外一个线程能够立刻看到。

## 3、有序性: 重排序引起
&emsp;&emsp;即程序执行的顺序按照代码的先后顺序执行

### 1)重排序
&emsp;&emsp;在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：
- 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
- 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
- 内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行

从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：


# 三、Java解决并发问题的: JMM(Java内存模型)
## 1、核心知识点
&emsp;&emsp;MM本质上可以理解为，Java 内存模型规范了 JVM 如何提供按需禁用缓存和编译优化的方法。<br>
&emsp;&emsp;具体来说，这些方法包括：
volatile、synchronized 和 final 三个关键字
Happens-Before 规则

## 2、可见性，有序性，原子性
### 1）原子性

```
//语句1: 直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中 
x = 10; 
//语句2: 包含2个操作，它先要去读取x的值，再将x的值写入工作内存；
//虽然读取x的值以及 将x的值写入工作内存这2个操作都是原子性操作，但是合起来就不是原子性操作了。
y = x; 
//语句3： x++包括3个操作：读取x的值，进行加1操作，写入新的值。
x++;
//语句4： 同语句3
x = x + 1;
```
&emsp;&emsp;Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。

### 2）可见性
&emsp;&emsp;对于可见性，Java提供了volatile关键字来保证可见性。<br>
&emsp;&emsp;当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。<br>
&emsp;&emsp;而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。<br>
&emsp;&emsp;另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。

### 3）有序性
&emsp;&emsp;　在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。<br>
&emsp;&emsp;在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。

## 3、happens-before原则
&emsp;&emsp;Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 **==happens==-before原则**。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。

### 1)happens-before原则（先行发生原则）：
- 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作<br>

- 锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作
- volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作<br>

- 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C<br>

- 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作

- 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生<br>
 
- 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行<br>

- 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始<br>


# 四、线程安全: 不是一个非真即假的命题
线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱顺序分成以下五类: 不可变、绝对线程安全、相对线程安全、线程兼容和线程对立

## 1. 不可变
不可变(Immutable)的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。只要一个不可变的对象被正确地构建出来，永远也不会看到它在多个线程之中处于不一致的状态。<br> 多线程环境下，应当尽量使对象成为不可变，来满足线程安全。<br> **不可变的类型:** <br>
- final 关键字修饰的基本数据类型 
- String 
- 枚举类型
- Number 部分子类，如 Long 和 Double 等数值包装类型，
BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。

## 2. 绝对线程安全 
 不管运行时环境如何，调用者都不需要任何额外的同步措施。 
##  3. 相对线程安全
相对线程安全需要保证对这个对象单独的操作是线程安全的，在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。 

在 Java 语言中，大部分的线程安全类都属于这种类型，例如 Vector、HashTable、Collections 的 synchronizedCollection() 方法包装的集合等。


## 4. 线程兼容 
线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。Java API 中大部分的类都是属于线程兼容的，如与前面的 Vector 和 HashTable 相对应的集合类 ArrayList 和 HashMap 等。

## 5. 线程对立

线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于 Java 语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免

# 五、线程安全的实现方法
## 1. 互斥同步（阻塞同步）
synchronized 和 ReentrantLock。
## 2、 非阻塞同步
###  &emsp; 1）CAS
###  &emsp; 2）原子类AtomicXXXX

## 3、无同步方案: 
### &emsp; 1）栈封闭
多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。


- JUC线程池: FutureTask详解
- JUC线程池: ThreadPoolExecutor详解
- JUC线程池: ScheduledThreadPool详解 
- JUC线程池: Fork/Join框架详解

### &emsp; 2）Thread Local Storage(线程本地存储)
如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行。如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。

符合这种特点的应用并不少见，大部分使用消费队列的架构模式(如“生产者-消费者”模式)都会将产品的消费过程尽量在一个线程中消费完。其中最重要的一个应用实例就是经典 Web 交互模型中的“一个请求对应一个服务器线程”(Thread-per-Request)的处理方式，这种处理方式的广泛应用使得很多 Web 服务端应用都可以使用线程本地存储来解决线程安全问题。

可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能
### &emsp; 3）可重入代码

这种代码也叫做纯代码(Pure Code)，可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。

可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。
# 六、内存模型
&emsp;&emsp;计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。<br>
&emsp;&emsp;也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。



