# 对象详解

JAVA的初始化顺序：父类的静态成员初始化>父类的静态代码块>子类的静态成员初始化>子类的静态代码块>父类的代码块>父类的构造方法>子类的代码块>子类的构造方法

# 一、对象的内存布局



**a.对象头（面试重点）** 

  **运行时元数据：主要包含对象的哈希值、GC分代年龄（from区向to区移动，分代年龄+1）、锁信息等** 

 类型指针：指向方法区（元空间）的类元数据，确定对象所属的类 

  **数组长度（如果为数组对象）** 

 b.实例数据 

 它是对象真正存储的有效信息，包括程序中定义的各种字段（包括从父类继承下来的和自己拥有的字段） 

 c.对齐填充 

 任何对象的大小都是8字节的整数倍，如果实例数据不满足，采用对齐填充进行补齐





# 二、创建对象

## 1、对象创建的方式

在Java中，一个对象在可以被使用之前必须要被正确地初始化

### 1.1 使用new关键字创建对象

### 1.2、反射机制

1）Class类的newInstance方法

2）使用Constructor类的newInstance方法

### 1.3、使用Clone方法

### 1.4、使用反序列化



## 2、Java 对象的创建过程

### 2.1、检测类是否被加载

虚拟机遇到一条new指令时，首先检查参数能否在常量池内定位到类的符号引用，并判断类是否已经被加载，解析和初始化，如果没有，那必须先执行相应的类加载过程。

### 2.2、为新生对象分配内存

接着虚拟机为对象分配内存，对象所需内存的大小在类加载完成后便可完全确定。

- 假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那么分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。
- 如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。
- 选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

### 2.3、初始化

内存分配完成后，虚拟机会将分配到的内存空间全部都初始化为零值(不包括对象头)，这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

### 2.4、进行必要的设置

接下来完成对对象头的设置 ：包括属于哪个类 如何找到类元数据 哈希码 GC分代年龄等信息。

这些信息存放在对象的对象头之中。

### 2.5、执行init方法

在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚开始，<init>方法还没有执行，所有的字段都还为零。所以一般来说，执行new指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。











# 三、常见问题

### 1、一个实例变量在对象初始化的过程中会被赋值几次？

我们知道，JVM在为一个对象分配完内存之后，会给每一个实例变量赋予默认值，这个时候实例变量被第一次赋值，这个赋值过程是没有办法避免的。如果我们在声明实例变量x的同时对其进行了赋值操作，那么这个时候，这个实例变量就被第二次赋值了。如果我们在实例代码块中，又对变量x做了初始化操作，那么这个时候，这个实例变量就被第三次赋值了。如果我们在构造函数中，也对变量x做了初始化操作，那么这个时候，变量x就被第四次赋值。也就是说，在Java的对象初始化过程中，一个实例变量最多可以被初始化4次。







# 参考文章

[深入理解Java对象的创建过程：类的初始化与实例化](https://blog.csdn.net/justloveyou_/article/details/72466416)

[Java创建对象的过程](cnblogs.com/CZDblog/p/5589379.html)



