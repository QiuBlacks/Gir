# 消息队列

# 一、基础知识

## 1、基本介绍

消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题。

实现高性能，高可用，可伸缩和最终一致性架构。

使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ。



## 2、优缺点

### 2.1 优点

- **异步处理**
- **服务解耦**
- **流量削锋**



### 2.2 缺点

- 系统可用性降低
  - 系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 BCD 三个系统的接口就好了，ABCD 四个系统还好好的，没啥问题，你偏加个 MQ 进来，万一 MQ 挂了咋整？MQ 一挂，整套系统崩溃，你不就完了？如何保证**消息队列的高可用**
- 系统复杂度提高
  - 硬生生加个 MQ 进来，你怎么**保证消息没有重复消费**？怎么**处理消息丢失**的情况？怎么保证消息传递的顺序性？
- 一致性问题





## 3、两种模型

RabbitMQ 采用队列模型，RocketMQ和Kafka 采用发布/订阅模型。

### 3.1 队列模型

生产者往某个队列里面发送消息，一个队列可以存储多个生产者的消息，一个队列也可以有多个消费者，但是消费者之间是竞争关系，即**每条消息只能被一个消费者消费**。



### 3.2 发布/订阅模型

**为了解决一条消息能被多个消费者消费的问题**，发布/订阅模型就来了。

该模型是将消息发往一个`Topic`即主题中，所有订阅了这个 `Topic` 的订阅者都能消费这条消息。



## 4、组成

- Producer：生产者 
- Consumer：消费者
- Broker：消息队列服务端

消息从Producer发往Broker，Broker将消息存储至本地，然后Consumer从Broker拉取消息，或者Broker推送消息至Consumer，最后消费。









# 如何保证消息不丢失？（可靠性）

考虑三种情况：分别在生产者、消息队列、消费者三个地方丢失消息

### 1、消费者：

唯一可能导致消费者弄丢数据的情况，就是说，你消费到了这个消息，然后消费者那边自动返回告诉Broker消费成功了，让 Broker以为你已经消费好了这个消息，但其实你才刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。

所以我们应该在**消费者真正执行完业务逻辑之后，再发送给`Broker`消费成功**，这才是真正的消费了。

### 2、消息队列Broker：

可以通过集群部署，主机挂了，还有从机。像RabbitMQ 可以开启持久化



### 3、生产者：

生产者将数据发送到 RabbitMQ 的时候，可能数据就在半路给搞丢了，因为网络问题啥的，都有可能。

生产者发送消息至Broker，需要处理Broker的响应，不论是同步还是异步发送消息，同步和异步回调都需要做好try-catch，妥善的处理响应，如果Broker返回写入失败等错误消息，需要重试发送。当多次发送失败需要作报警，日志记录等。

RabbitMQ 提供了事务机制和 confirm 机制。**事务机制是同步的**，你提交一个事务之后会**阻塞**在那儿，但是 `confirm` 机制是**异步**的，你发送个消息之后就可以发送下一个消息，然后那个消息 RabbitMQ 接收了之后会异步回调你的一个接口通知你这个消息接收到了。



# 如何保证消息不被重复消费？

### 1、场景

一般情况下，我们发消息至少得发到`Broker`上，然后等`Broker`的响应，那么就可能存在`Broker`已经写入了，当时响应由于网络原因生产者没有收到，然后生产者又重发了一次，此时消息就重复了。

### 2、解决方案：保证幂等性

幂等性，通俗点说，就一个数据，或者一个请求，给你重复来多次，你得确保对应的数据是不会改变的，**不能出错**。



- 比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。
- 比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。
- 比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。
- 比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据



# 如何保证消息的有序性？

### 1、场景分析

在 mysql 里增删改一条数据，对应出来了增删改 3 条 `binlog` 日志，接着这三条 `binlog` 发送到 MQ 里面，再消费出来依次执行，起码得保证人家是按照顺序来的吧？不然本来是：增加、修改、删除；你愣是换了顺序给执行成删除、修改、增加，不全错了么。

### 2、解决方案

RabbitMQ

拆分多个 queue，每个消费者consumer 固定消费一个 queue 的消息，或者就一个 queue 但是对应一个 consumer。因为上传到同一个queue 的消息肯定有序。然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。 

![image-20201215212708827](https://gitee.com/BlacksJack/picture-bed/raw/master/img/20201215213422.png)



# 如果处理消息堆积？





# 参考文章

[为什么使用消息队列](https://doocs.gitee.io/advanced-java/#/./docs/high-concurrency/why-mq?id=为什么使用消息队列)

https://www.nowcoder.com/discuss/568122