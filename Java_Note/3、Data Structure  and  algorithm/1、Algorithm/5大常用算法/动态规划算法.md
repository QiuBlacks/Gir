# 动态规划算法
--------------------------------------------------------------------------------
## 一、核心思想
巧妙的将问题拆分成多个子问题，通过计算子问题而得到整体问题的解。而子问题又可以拆分成更多的子问题，从而用类似递推迭代的方法解决要求的问题。<br>

与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）



## 二、解题核心
第一步：状态的定义
		第二步：状态转移方程的定义



## 三、应用场景
对于一个可拆分问题中存在可以由前若干项计算当前项的问题可以由动态规划计算

## 四、分治与动态规划的区别
### 相同点：
其基本思想都是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解（合并）得到原问题的解。
### 不同点：
 分治法将分解后的子问题看成相互独立的，通过用递归来做。<br>
　　动态规划将分解后的子问题理解为相互间有联系,有重叠部分，需要记忆，通常用迭代来做。 

## 五、设计步骤
- 1.描述最优解的结构，可以利用子问题的最优解来构造原问题的最优解；
- 2.递归定义最优解的值
- 3.按自底向上的方式计算最优解的值
- 4.由计算出的结果构造一个最优解

## 六、实例

题目：
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

递归法：

```Java
public int climbStairs (int n) {
    if (n < 1) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    if (n == 2) {
        return 2;
    }

    return climbStairs(n - 1) + climbStairs(n - 2);
}
```


递归的过程中包含着大量的重复操作，把执行过的数据用表（数组）保存起来，后面要用到的话直接查dp表(step)调用可以节约大量的时间

动态规划

```java
public int climbStairs (int n) {
    if (n == 1){
        return 1;
    }// 防止数组越界
    int[] step = new int[n + 1];
    step[1] = 1;
    step[2] = 2;
    for (int i = 3; i <= n; i++) {
        step[i] = step[i - 1] + step[i - 2];
    }
    return step[n];
}
```

